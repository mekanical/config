=begin
For Arakawa FDTD modeling tool

Ver 1.1.0
  add MSL feed
  定数による色の管理
  Draw function の追加
Color set
  Orange(255, 128, 0) MSL feed

History
Ver 1.0.0
  CPW feed, CPW feed end, Throgh hole
Color set
  Red(255, 0, 0) Y+ feed
  Blue(0, 0, 255) Y+ feed end
  Yellow(255, 255, 05) Y- feed
  LightBlue(0, 255, 255) Y- feed end

  Puple(255, 0, 255) Thrgh hole

Created by Sugimoto
=end

#file name
$outFileName = ARGV[0] #"test"
topFileName = ARGV[1] #"top.bmp"
bottomFileName = ARGV[2] #nil #"bottom_thick2.bmp"

# fdtd paramater
$nx = 180; $ny = 180; $nz = 100; $nt = 8000
$dx = "0.1d-3"; $dy = "0.1d-3"; $dz = "0.1d-3"

$freqS_imp = "8.0d9"; $freqE_imp = "20.0d9"; $freqPoint_imp = "501"

$patFrag = "1"; $effFrag = "1"; $patAngle = "180"
$freqS_pat = "1.0d9"; $freqE_pat = "5.0d9"; $freqPoint_pat = "11"
$XS_pat = "30"; $YS_pat = "30"; $ZS_pat = "20"
$XE_pat = "150"; $YE_pat = "150"; $ZE_pat = "80"

# substrate paramater
dz = 0.1e-3
substrateDepth = ARGV[3].to_f; substrateDepthCells = (substrateDepth/dz).round
epsR = 10.2; freq = 2.0e9; tanD = 0.005
substrateSigma = tanD * 2 * 3.141592653 * freq * 8.85418782e-12 * epsR

puts substrateDepth

# feed paramater
$nfeed = 1
$innerR = "50.0d0"; $type = "1"
$tau = "20.0d0 * dt"

# temp
$baseZ = 0

# Color Mange
BLACK = 0
WHITE = 1
RED = 2
YELLOW = 3
BLUE = 4
SKYBLUE = 5
GREEN = 6
PURPLE = 7
ORANGE = 8
LIGHTBLUE = 9

#色の管理を定数で便利に
R=0
G=1
B=2

# BitMap class ------------------------------------------------------
class BitMap
  def initialize(width, height, dpi = 96)
    @width = width
    @height = height
    @line_size = width * 3 + (4 - (width * 3) % 4) % 4
    @buf_size = @line_size * height
    @buf = "\000" * @buf_size
    @bit_count = 24
    @compression = 0  # 圧縮無し
    @size_image = 0
    @x_pix_per_meter = (39.375 * dpi).round
    @y_pix_per_meter = (39.375 * dpi).round
    @clr_used = 0
    @cir_important = 0
  end

  def clear(r = 255, g = 255, b = 255)
    line = b.chr * @line_size
    @width.times do |x|
      line[x * 3 + 1] = g
      line[x * 3 + 2] = r
    end

    @buf = line * @height
  end

  attr_writer :buf
  attr_reader :width, :height

  # BMPファイルを出力する
  def write(filename)
    file_size = 14 + 40 + @buf_size
    data_offset = 14 + 40

    open(filename, "wb") do |f|
      f.print 'BM'
      f.print [file_size, 0, data_offset].pack("l*")
      f.print [40, @width, @height].pack("l*")
      f.print [1, @bit_count].pack("S*")
      f.print [@compression, @size_image,
               @x_pix_per_meter, @y_pix_per_meter,
               @clr_used, @cir_important].pack("l*")
      f.print @buf
    end
  end


  # BMPファイルを読み込む
  def BitMap.read(filename)
    buf = nil
    open(filename, "rb") do |f|
      buf = f.read
    end

    if buf[0] != ?B or buf[1] != ?M
      raise('[Error] read: Invalid Header')
    end
    real_buf_size = buf.size
    buf_size = (buf[2, 4].unpack("l*"))[0]
    if buf_size > real_buf_size
      raise('[Error] read: Invalid Buffer Size')
    end
    data_offset = (buf[10, 4].unpack("l*"))[0]
    if data_offset != 54
      raise('[Error] read: Invalid Data Offset')
    end

    width = (buf[18, 4].unpack("l*"))[0]
    height = (buf[22, 4].unpack("l*"))[0]

    bit_count = (buf[28, 2].unpack("s*"))[0]
    if bit_count != 24
      raise('[Error] read: Unsupported Color Depth')
    end

    compression = (buf[30, 4].unpack("l*"))[0]
    if compression != 0
      raise('[Error] read: Compression Not Supported')
    end

    pix_per_meter = (buf[38, 4].unpack("l*"))[0]
    dpi = pix_per_meter / 39.375

    image_buf = buf[54, buf_size]

    image = BitMap.new(width, height, dpi)
    image.buf = image_buf

    return image
  end


  # (x1, y1) - (x2, y2)の部分画像を取り出す
  def clip(x1, y1, x2, y2)
    return if x1 > x2
    return if y1 > y2
    return if x2 < 0
    return if y2 < 0
    return if x1 >= @width
    return if y1 >= @height
    x1 = 0 if x1 < 0
    y1 = 0 if y1 < 0
    x2 = @width - 1  if x2 >= @width
    y2 = @height - 1 if y2 >= @height

    clip_width  = x2 - x1 + 1
    clip_height = y2 - y1 + 1

    clip_image = BitMap.new(clip_width, clip_height, self.get_dpi)

    for y in 0 .. (clip_height - 1)
      for x in 0 .. (clip_width - 1)
        color = self.pget(x1 + x, y1 + y)
        clip_image.pset(x, y, color[0], color[1], color[2])
      end
    end

    return clip_image
  end


  # x, y, r, g, b は整数であることを期待している
  def pset(x, y, r, g, b)
    return if x < 0 or @width <= x
    return if y < 0 or @height <= y
    r = 0 if r < 0
    g = 0 if g < 0
    b = 0 if b < 0
    r = 255 if r > 255
    g = 255 if g > 255
    b = 255 if b > 255

    @buf[(@height - 1 - y) * @line_size + x * 3    ] = b
    @buf[(@height - 1 - y) * @line_size + x * 3 + 1] = g
    @buf[(@height - 1 - y) * @line_size + x * 3 + 2] = r
  end

  # x, yは整数であることを期待している
  # 戻り値は[r, g, b]な配列
  def pget(x, y)
    x = 0 if x < 0
    x = @width - 1 if x >= @width
    y = 0 if y < 0
    y = @height - 1 if y >= @height

    addr = (@height - 1 - y) * @line_size + x * 3
    b = @buf[addr    ]
    g = @buf[addr + 1]
    r = @buf[addr + 2]

    return [r, g, b]
  end

  def get_dpi()
    return (@x_pix_per_meter / 39.375).round
  end

  def set_dpi(dpi)
    @x_pix_per_meter = (39.375 * dpi).round
    @y_pix_per_meter = @x_pix_per_meter
  end

  # x0, y0 は、貼り付ける始点(左上)の座標
  def paste(image, x0 = 0, y0 = 0)
    return if image == nil
    image.height.times do |from_y|
      y = y0 + from_y
      next if y < 0 or @height <= y

      image.width.times do |from_x|
        x = x0 + from_x
        next if x < 0 or @width <= x
        color = image.pget(from_x, from_y)
        self.pset(x, y, color[0], color[1], color[2])
      end
    end

  end
end

def outSetHeader()
  file = File.open($outFileName+".f90","a")
    file.print(
      "!ARfdtd modelinged by sugimoto modeling tool\n",
      "include 'MPI_dummy.f90'\n",
      "!module setup\n",
      "!implicit none\n",
      "!include 'mpif.h'\n",
      "module setup\n",
      "  use MPI_dummy\n",
      "  implicit none\n",
      "  ! Constant\n",
      "  ! Don't touch without ZL.\n",
      "  ! (ZL is characteristic impedance on transmission line.)\n",
      "  real*8, parameter :: pi = 3.1415926535897932384626433832795028841971693993751d0\n",
      "  real*8, parameter :: DBL_EPSILON = 1.0d-5\n",
      "  real*8, parameter :: c = 2.99792458d8\n",
      "  real*8, parameter :: mu0 = 4.0d0*pi*1.0d-7\n",
      "  real*8, parameter :: eps0 = 1.0d0/(mu0*c*c)\n",
      "  real*8, parameter :: sgm0 = 0.0d0\n",
      "  real*8, parameter :: Z0 = 120.0d0*pi\n",
      "  real*8, parameter :: ZL = 50.0d0\n",
      "  ! File name\n",
      "  character*128, parameter :: filename='#{$outFileName}'\n",
      "  ! FDTD setup\n",
      "  integer, parameter :: nx=#{$nx}\n",
      "  integer, parameter :: ny=#{$ny}\n",
      "  integer, parameter :: nz=#{$nz}\n",
      "  integer, parameter :: nt=#{$nt}\n",
      "  integer, parameter :: nfeed=#{$nfeed}\n",
      "  real*8, parameter :: dx=#{$dx}\n",
      "  real*8, parameter :: dy=#{$dy}\n",
      "  real*8, parameter :: dz=#{$dz}\n",
      "  real*8, parameter :: CFL=0.9995d0\n",
      "  ! Modeling Mode(unpopulated)\n",
      "  ! 0 : Arakawa Engine\n",
      "  ! 1 : ASoC-compatible Engine\n",
      "  integer, parameter :: ModelingMode=0\n",
      "  ! PML setup\n",
      "  integer, parameter :: LM=8\n",
      "  integer, parameter :: MM=4\n",
      "  real*8, parameter :: RC0 = -120.0d0\n",
      "  ! impedance setup\n",
      "  ! if you need not impedance data, please set impedanceFlag to 0.\n",
      "  real*8, parameter :: freqS_imp = #{$freqS_imp}\n",
      "  real*8, parameter :: freqE_imp = #{$freqE_imp}\n",
      "  integer, parameter :: freqPoint_imp = #{$freqPoint_imp}\n",
      "  integer, parameter :: impedanceFlag = 1\n",
      "  ! pattern setup\n",
      "  ! If you need not pattern data, please set patternFlag to 0.\n",
      "  ! If you need not efficiency data, please set efficiencyFlag to 0.\n",
      "  integer, parameter :: nAngle = #{$patAngle}\n",
      "  real*8, parameter :: freqS_pat = #{$freqS_pat}\n",
      "  real*8, parameter :: freqE_pat = #{$freqE_pat}\n",
      "  integer, parameter :: freqPoint_pat = #{$freqPoint_pat}\n",
      "  integer, parameter :: XS_pat = #{$XS_pat}, YS_pat = #{$YS_pat}, ZS_pat = #{$ZS_pat}\n",
      "  integer, parameter :: XE_pat = #{$XE_pat}, YE_pat = #{$YE_pat}, ZE_pat = #{$ZE_pat}\n",
      "  integer, parameter :: patternFlag = #{$patFrag}\n",
      "  integer, parameter :: efficiencyFlag = #{$effFrag}\n",
      "  ! Current distribution\n",
      "  ! XS_CD == XE_CD : Y-Z plane\n",
      "  ! YS_CD == YE_CD : X-Z plane\n",
      "  ! ZS_CD == ZE_CD : X-Y plane\n",
      "  integer, parameter :: CDFlag = 0\n",
      "  integer, parameter :: XS_CD = 0, YS_CD = 0, ZS_CD = 0\n",
      "  integer, parameter :: XE_CD = 10, YE_CD = 10, ZE_CD = 10\n",
      "  real*8, parameter :: freqS_CD = 0d9\n",
      "  real*8, parameter :: freqE_CD = 1d9\n",
      "  integer, parameter :: freqPoint_CD = 2\n",
      "  complex*16, dimension(:,:,:), allocatable :: Jx, Jy, Jz\n",
      "  complex*16, dimension(:,:), allocatable :: Jl\n",
      "  integer :: ZSL_CD, ZEL_CD\n",
      "  ! Electric field distribution\n",
      "  ! XS_ED == XE_ED : Y-Z plane\n",
      "  ! YS_ED == YE_ED : X-Z plan\n",
      "  ! ZS_ED == ZE_ED : X-Y plane\n",
      "  integer, parameter :: EDFlag = 0\n",
      "  integer, parameter :: XS_ED = 0, YS_ED = 0, ZS_ED = 0\n",
      "  integer, parameter :: XE_ED = 10, YE_ED = 10, ZE_ED = 10\n",
      "  real*8, parameter :: freqS_ED = 3.0d9\n",
      "  real*8, parameter :: freqE_ED = 11.0d9\n",
      "  integer, parameter :: freqPoint_ED = 1\n",
      "  complex*16, dimension(:,:,:), allocatable :: Ex_ED, Ey_ED, Ez_ED\n",
      "  integer :: ZSL_ED, ZEL_ED\n",
      "  ! PLRC setup\n",
      "  ! If you don't use PLRC-method set PLRCFlag to 0.\n",
      "  integer, parameter :: XS_RC = 10, YS_RC = 10, ZS_RC = 10\n",
      "  integer, parameter :: XE_RC = 90, YE_RC = 90, ZE_RC = 90\n",
      "  integer, parameter :: PLRCFlag = 0\n",
      "  ! CP setup\n",
      "  ! If you don't use CP-FDTD, please set CPFlag to 0.\n",
      "  integer, parameter :: CPFlag = 0\n",
      "  ! ID setup\n",
      "  integer, parameter :: ListMax = 128\n",
      "  ! dt, df\n",
      "  real*8 :: dt, df\n",
      "  ! E-field array\n",
      "  real*8, dimension(:,:,:), allocatable :: Ex,Ey,Ez\n",
      "  real*8, dimension(:,:,:), allocatable :: Exy1,Exz1, Eyx1,Eyz1, Ezx1,Ezy1\n",
      "  real*8, dimension(:,:,:), allocatable :: Exy2,Exz2, Eyx2,Eyz2, Ezx2,Ezy2\n",
      "  real*8, dimension(:,:,:), allocatable :: Exy3,Exz3, Eyx3,Eyz3, Ezx3,Ezy3\n",
      "  real*8, dimension(:,:,:), allocatable :: Exy4,Exz4, Eyx4,Eyz4, Ezx4,Ezy4\n",
      "  real*8, dimension(:,:,:), allocatable :: Exy5,Exz5, Eyx5,Eyz5, Ezx5,Ezy5\n",
      "  real*8, dimension(:,:,:), allocatable :: Exy6,Exz6, Eyx6,Eyz6, Ezx6,Ezy6\n",
      "  ! H-field array\n",
      "  real*8, dimension(:,:,:), allocatable :: Hx,Hy,Hz\n",
      "  real*8, dimension(:,:,:), allocatable :: Hxy1,Hxz1, Hyx1,Hyz1, Hzx1,Hzy1\n",
      "  real*8, dimension(:,:,:), allocatable :: Hxy2,Hxz2, Hyx2,Hyz2, Hzx2,Hzy2\n",
      "  real*8, dimension(:,:,:), allocatable :: Hxy3,Hxz3, Hyx3,Hyz3, Hzx3,Hzy3\n",
      "  real*8, dimension(:,:,:), allocatable :: Hxy4,Hxz4, Hyx4,Hyz4, Hzx4,Hzy4\n",
      "  real*8, dimension(:,:,:), allocatable :: Hxy5,Hxz5, Hyx5,Hyz5, Hzx5,Hzy5\n",
      "  real*8, dimension(:,:,:), allocatable :: Hxy6,Hxz6, Hyx6,Hyz6, Hzx6,Hzy6\n",
      "  ! Material array\n",
      "  integer, dimension(:,:,:), allocatable :: IDEx,IDEy,IDEz\n",
      "  integer, dimension(:,:,:), allocatable :: IDHx,IDHy,IDHz\n",
      "  real*8 :: CEx(-1:ListMax+1), CExLy(-1:ListMax+1), CExLz(-1:ListMax+1)\n",
      "  real*8 :: CEy(-1:ListMax+1), CEyLz(-1:ListMax+1), CEyLx(-1:ListMax+1)\n",
      "  real*8 :: CEz(-1:ListMax+1), CEzLx(-1:ListMax+1), CEzLy(-1:ListMax+1)\n",
      "  real*8 :: CPhi(-1:ListMax+1)\n",
      "  real*8 :: CPhi1(-1:ListMax+1), CPhi2(-1:ListMax+1), CPhi3(-1:ListMax+1)\n",
      "  real*8 :: CHxLy(0:ListMax+1), CHxLz(0:ListMax+1)\n",
      "  real*8 :: CHyLz(0:ListMax+1), CHyLx(0:ListMax+1)\n",
      "  real*8 :: CHzLx(0:ListMax+1), CHzLy(0:ListMax+1)\n",
      "  real*8 :: CpmlEdx(1:nx), CpmlEdy(1:ny), CpmlEdz(1:nz)\n",
      "  real*8 :: CpmlEdxL(1:nx), CpmlEdyL(1:ny), CpmlEdzL(1:nz)\n",
      "  real*8 :: CpmlHdx(1:nx), CpmlHdy(1:ny), CpmlHdz(1:nz)\n",
      "  real*8 :: CpmlHdxL(1:nx), CpmlHdyL(1:ny), CpmlHdzL(1:nz)\n",
      "  ! feed array\n",
      "  integer :: feedx(nfeed), feedy(nfeed), feedz(nfeed)\n",
      "  integer :: feedcx(nfeed), feedcy(nfeed), feedcz(nfeed), feedNode(nfeed)\n",
      "  integer :: feedLength(nfeed)\n",
      "  character :: feedAxis(nfeed)\n",
      "  integer :: feedSign(nfeed)\n",
      "  real*8 :: feedR(nfeed)\n",
      "  integer :: feedType(nfeed)\n",
      "  real*8 :: feedTAU(nfeed), feedOMEGA(nfeed), feedALPHA(nfeed)\n",
      "  real*8 :: feedAMP(nfeed)\n",
      "  real*8 ::feed\n",
      "  ! impedance array\n",
      "  real*8 :: It(nfeed), Vt(nfeed)\n",
      "  complex*16 :: If_imp(freqPoint_imp, nfeed), Vf_imp(freqPoint_imp, nfeed)\n",
      "  complex*16 :: imp(freqPoint_imp, nfeed)\n",
      "  ! pattern array\n",
      "  complex*16, dimension(:,:,:), allocatable :: Ey1, Ez1, Hy1, Hz1\n",
      "  complex*16, dimension(:,:,:), allocatable :: Ey2, Ez2, Hy2, Hz2\n",
      "  complex*16, dimension(:,:,:), allocatable :: Ez3, Ex3, Hz3, Hx3\n",
      "  complex*16, dimension(:,:,:), allocatable :: Ez4, Ex4, Hz4, Hx4\n",
      "  complex*16, dimension(:,:,:), allocatable :: Ex5, Ey5, Hx5, Hy5\n",
      "  complex*16, dimension(:,:,:), allocatable :: Ex6, Ey6, Hx6, Hy6\n",
      "  complex*16 :: If_pat(freqPoint_pat, nfeed), Vf_pat(freqPoint_pat, nfeed)\n",
      "  real*8 :: Pin(freqPoint_pat)\n",
      "  real*8 :: Prad(freqPoint_pat)\n",
      "  integer :: ZSL_pat, ZEL_pat\n",
      "  real*8 :: XC_pat, YC_pat, ZC_pat\n",
      "  ! PLRC array\n",
      "  real*8, dimension(:,:,:), allocatable :: ExSaveRC, EySaveRC, EzSaveRC\n",
      "  real*8, dimension(:,:,:), allocatable :: PHIx, PHIy, PHIz\n",
      "  integer :: ZSL_RC, ZEL_RC\n",
      "  ! CP array\n",
      "  integer, save :: cpPoint = 0\n",
      "  integer, dimension(:), allocatable :: cpX, cpY, cpZ, cpPlaneFlag\n",
      "  real*8, dimension(:), allocatable :: llx1,lly1,llz1, llx2,lly2,llz2\n",
      "  real*8, dimension(:), allocatable :: sq, CHCP\n",
      "  integer :: cpS(1:nz), cpE(1:nz)\n",
      "  ! roop counter\n",
      "  integer :: t\n",
      "  ! MPI parameter\n",
      "  integer :: np, id\n",
      "  integer :: zm, zp\n",
      "  integer :: tag = 0\n",
      "  integer :: status(MPI_STATUS_SIZE, 4)\n",
      "  integer :: request(4)\n",
      "  integer :: error_code\n",
      "  integer :: MatrixXY\n",
      "  ! Load barancing parameter\n",
      "  integer, dimension(:), allocatable :: nzS, nzE, nzL\n",
      "  ! Avoid from compiler's alart\n",
      "  real*8 :: trush\n",
      "  ! interface\n",
      "  interface setCP\n",
      "     module procedure setCP_integer\n",
      "     module procedure setCP_real\n",
      "  end interface\n",
      "  interface setline\n",
      "     module procedure ARsetline\n",
      "     module procedure ASoCsetline\n",
      "  end interface\n",
      "  interface setplane\n",
      "     module procedure ARsetplane\n",
      "     module procedure ASoCsetplane\n",
      "  end interface\n",
      "  interface setfeed\n",
      "     module procedure ARsetfeed\n",
      "     module procedure ASoCsetfeed\n",
      "  end interface\n",
      "contains\n",
      "  subroutine beforeInit\n",
      "  end subroutine beforeInit\n",
      "\n",
      "  subroutine setmodel !------------------------------------------------------------\n",
      "    ! setfeed(feedNo, x1,y1,z1, x2,y2,z2, fR, fType, fTAU, fAMP)\n",
      "    ! setline(materialID, x1,y1,z1, x2,y2,z2)\n",
      "    ! setplane(materialID, x1,y1,z1, x2,y2,z2)\n",
      "    ! setbox(materialID, x1,y1,z1, x2,y2,z2)\n",
      "    ! setoval(materialID, x1,y1,z1, x2,y2,z2)\n",
      "    ! setovalCP(materialID, x1,y1,z1, x2,y2,z2)\n",
      "   !-------------------------------------!\n",
      "   !          ID    SIG    EPR           !\n",
      "   !-------------------------------------!\n\n\n"
    )
  file.close
end

def outSetFooter()
  file = File.open($outFileName+".f90","a")
    file.print(
      "  end subroutine setmodel\n\n",
      "  subroutine setmaterial(materialID, sgm, eps, mu)\n",
      "    integer :: materialID\n",
      "    real*8 :: sgm,eps,mu\n",
      "    if((materialID >= 2) .and. (materialID <= ListMax+1)) then\n",
      "       CEx(materialID) = (1.0d0-sgm*dt/2.0d0/eps)/(1.0d0+sgm*dt/2.0d0/eps)\n",
      "       CExLy(materialID) = dt/eps/(1.0d0+sgm*dt/2.0d0/eps)/dy\n",
      "       CExLz(materialID) = dt/eps/(1.0d0+sgm*dt/2.0d0/eps)/dz\n",
      "       CEy(materialID) = (1.0d0-sgm*dt/2.0d0/eps)/(1.0d0+sgm*dt/2.0d0/eps)\n",
      "       CEyLz(materialID) = dt/eps/(1.0d0+sgm*dt/2.0d0/eps)/dz\n",
      "       CEyLx(materialID) = dt/eps/(1.0d0+sgm*dt/2.0d0/eps)/dx\n",
      "       CEz(materialID) = (1.0d0-sgm*dt/2.0d0/eps)/(1.0d0+sgm*dt/2.0d0/eps)\n",
      "       CEzLx(materialID) = dt/eps/(1.0d0+sgm*dt/2.0d0/eps)/dx\n",
      "       CEzLy(materialID) = dt/eps/(1.0d0+sgm*dt/2.0d0/eps)/dy\n",
      "    \n",
      "       CPhi(materialID) = 0.0d0\n",
      "       CPhi1(materialID) = 0.0d0\n",
      "       CPhi2(materialID) = 0.0d0\n",
      "       CPhi3(materialID) = 0.0d0\n",
      "       \n",
      "       CHxLy(materialID) = dt/mu/dy\n",
      "       CHxLz(materialID) = dt/mu/dz\n",
      "       CHyLz(materialID) = dt/mu/dz\n",
      "       CHyLx(materialID) = dt/mu/dx\n",
      "       CHzLx(materialID) = dt/mu/dx\n",
      "       CHzLy(materialID) = dt/mu/dy\n",
      "    else if((materialID == 0) .or. (materialID == 1)) then\n",
      "       stop \"Don't use materialID 0 or materialID 1. Error. (setmaterial)\"\n",
      "    endif\n",
      "  end subroutine setmaterial\n",
      "  subroutine MEDIUM(materialID, sgm, epsr)\n",
      "    integer :: materialID\n",
      "    real*8 :: sgm,epsr\n",
      "    call setmaterial(materialID, sgm, epsr*eps0, mu0)\n",
      "  end subroutine MEDIUM\n",
      "  subroutine setmaterialDebye(materialID, eps_s, eps_inf, t0, mu)\n",
      "    integer :: materialID\n",
      "    real*8 :: eps_s, eps_inf, t0, mu\n",
      "    real*8 :: chi0, dchi0, xi0, dxi0\n",
      "    \n",
      "    chi0 = (eps_s - eps_inf)*(1.0d0-exp(-dt/t0))\n",
      "    dchi0 = chi0 * (1.0d0-exp(-dt/t0))\n",
      "    xi0 = -(eps_s - eps_inf)*t0/dt*((1.0d0+dt/t0)*exp(-dt/t0)-1.0d0)\n",
      "    dxi0 = xi0 * (1.0d0-exp(-dt/t0))\n",
      "    \n",
      "    CEx(materialID) = (eps_inf - xi0)/(eps_inf + chi0 - xi0)\n",
      "    CExLy(materialID) = dt/eps0/(eps_inf + chi0 - xi0)/dy\n",
      "    CExLz(materialID) = dt/eps0/(eps_inf + chi0 - xi0)/dz\n",
      "    CEy(materialID) = (eps_inf - xi0)/(eps_inf + chi0 - xi0)\n",
      "    CEyLz(materialID) = dt/eps0/(eps_inf + chi0 - xi0)/dz\n",
      "    CEyLx(materialID) = dt/eps0/(eps_inf + chi0 - xi0)/dx\n",
      "    CEz(materialID) = (eps_inf - xi0)/(eps_inf + chi0 - xi0)\n",
      "    CEzLx(materialID) = dt/eps0/(eps_inf + chi0 - xi0)/dx\n",
      "    CEzLy(materialID) = dt/eps0/(eps_inf + chi0 - xi0)/dy\n",
      "    \n",
      "    CPhi(materialID) = 1.0d0/(eps_inf+chi0-xi0)\n",
      "    CPhi1(materialID) = dchi0 - dxi0\n",
      "    CPhi2(materialID) = dxi0\n",
      "    CPhi3(materialID) = exp(-dt/t0)\n",
      "    CHxLy(materialID) = dt/mu/dy\n",
      "    CHxLz(materialID) = dt/mu/dz\n",
      "    CHyLz(materialID) = dt/mu/dz\n",
      "    CHyLx(materialID) = dt/mu/dx\n",
      "    CHzLx(materialID) = dt/mu/dx\n",
      "    CHzLy(materialID) = dt/mu/dy\n",
      "  end subroutine setmaterialDebye\n",
      "  subroutine setResistance(materialID, R)\n",
      "    integer :: materialID\n",
      "    real*8 :: R\n",
      "    \n",
      "    if(R == 0.0d0) then\n",
      "       stop 'Error. R = 0. Please use materialID = 1 (PEC).'\n",
      "    end if\n",
      "    CEx(materialID) = (1.0d0-dt*dx/2.0d0/R/eps0/dy/dz) &\n",
      "         & / (1.0d0+dt*dx/2.0d0/R/eps0/dy/dz)\n",
      "    CExLy(materialID) = dt/eps0&\n",
      "         & / (1.0d0+dt*dx/2.0d0/R/eps0/dy/dz)/dy\n",
      "    CExLz(materialID) = dt/eps0&\n",
      "         & / (1.0d0+dt*dx/2.0d0/R/eps0/dy/dz)/dz\n",
      "    CEy(materialID) = (1.0d0-dt*dy/2.0d0/R/eps0/dz/dx) &\n",
      "         & / (1.0d0+dt*dy/2.0d0/R/eps0/dz/dx)\n",
      "    CEyLz(materialID) = dt/eps0 &\n",
      "         & / (1.0d0+dt*dy/2.0d0/R/eps0/dz/dx)/dz\n",
      "    CEyLx(materialID) = dt/eps0 &\n",
      "         & / (1.0d0+dt*dy/2.0d0/R/eps0/dz/dx)/dx\n",
      "    CEz(materialID) = (1.0d0-dt*dz/2.0d0/R/eps0/dx/dy) &\n",
      "         & / (1.0d0+dt*dz/2.0d0/R/eps0/dx/dy)\n",
      "    CEzLx(materialID) = dt/eps0 &\n",
      "         & / (1.0d0+dt*dz/2.0d0/R/eps0/dx/dy)/dx\n",
      "    CEzLy(materialID) = dt/eps0 &\n",
      "         & / (1.0d0+dt*dz/2.0d0/R/eps0/dx/dy)/dy\n",
      "    \n",
      "    CPhi(materialID) = 0.0d0\n",
      "    CPhi1(materialID) = 0.0d0\n",
      "    CPhi2(materialID) = 0.0d0\n",
      "    CPhi3(materialID) = 0.0d0\n",
      "       \n",
      "    CHxLy(materialID) = dt/mu0/dy\n",
      "    CHxLz(materialID) = dt/mu0/dz\n",
      "    CHyLz(materialID) = dt/mu0/dz\n",
      "    CHyLx(materialID) = dt/mu0/dx\n",
      "    CHzLx(materialID) = dt/mu0/dx\n",
      "    CHzLy(materialID) = dt/mu0/dy\n",
      "  end subroutine setResistance\n",
      "  subroutine setCondenser(materialID, Cap)\n",
      "    integer :: materialID\n",
      "    real*8 :: Cap\n",
      "    \n",
      "    CEx(materialID) = 1.0d0\n",
      "    CExLy(materialID) = dt/eps0/(1.0d0+Cap*dx/eps0/dy/dz)/dy\n",
      "    CExLz(materialID) = dt/eps0/(1.0d0+Cap*dx/eps0/dy/dz)/dz\n",
      "    CEy(materialID) = 1.0d0\n",
      "    CEyLz(materialID) = dt/eps0/(1.0d0+Cap*dy/eps0/dz/dx)/dz\n",
      "    CEyLx(materialID) = dt/eps0/(1.0d0+Cap*dy/eps0/dz/dx)/dx\n",
      "    CEz(materialID) = 1.0d0\n",
      "    CEzLx(materialID) = dt/eps0/(1.0d0+Cap*dz/eps0/dx/dy)/dx\n",
      "    CEzLy(materialID) = dt/eps0/(1.0d0+Cap*dz/eps0/dx/dy)/dy\n",
      "    \n",
      "    CPhi(materialID) = 0.0d0\n",
      "    CPhi1(materialID) = 0.0d0\n",
      "    CPhi2(materialID) = 0.0d0\n",
      "    CPhi3(materialID) = 0.0d0\n",
      "       \n",
      "    CHxLy(materialID) = dt/mu0/dy\n",
      "    CHxLz(materialID) = dt/mu0/dz\n",
      "    CHyLz(materialID) = dt/mu0/dz\n",
      "    CHyLx(materialID) = dt/mu0/dx\n",
      "    CHzLx(materialID) = dt/mu0/dx\n",
      "    CHzLy(materialID) = dt/mu0/dy\n",
      "  end subroutine setCondenser\n",
      "  \n",
      "  subroutine ARsetfeed(feedNo, x1,y1,z1, x2,y2,z2, fR, fType, fTAU, fAMP)\n",
      "    integer :: feedNo\n",
      "    integer :: x1,y1,z1, x2,y2,z2\n",
      "    real*8 :: fR\n",
      "    integer :: fType\n",
      "    real*8 :: fTAU, fAMP\n",
      "    integer :: p\n",
      "    \n",
      "    feedx(feedNo) = x1\n",
      "    feedy(feedNo) = y1\n",
      "    feedz(feedNo) = z1\n",
      "    feedcx(feedNo) = x1\n",
      "    feedcy(feedNo) = y1\n",
      "    feedcz(feedNo) = z1\n",
      "    feedLength(feedNo) = abs((x2-x1)+(y2-y1)+(z2-z1))\n",
      "    if(x1 < x2 .and. y1 == y2 .and. z1 == z2) then\n",
      "       feedAxis(feedNo) = 'x'\n",
      "       feedSign(feedNo) = +1\n",
      "       feedx(feedNo) = x1\n",
      "       feedcx(feedNo) = x1 + (feedLength(feedNo)-1)/2\n",
      "    else if(x1 > x2 .and. y1 == y2 .and. z1 == z2) then\n",
      "       feedAxis(feedNo) = 'x'\n",
      "       feedSign(feedNo) = -1\n",
      "       feedx(feedNo) = x1-1\n",
      "       feedcx(feedNo) = x1 - (feedLength(feedNo)+1)/2\n",
      "    else if(x1 == x2 .and. y1 < y2 .and. z1 == z2) then\n",
      "       feedAxis(feedNo) = 'y'\n",
      "       feedSign(feedNo) = +1\n",
      "       feedy(feedNo) = y1\n",
      "       feedcy(feedNo) = y1 + (feedLength(feedNo)-1)/2\n",
      "    else if(x1 == x2 .and. y1 > y2 .and. z1 == z2) then\n",
      "       feedAxis(feedNo) = 'y'\n",
      "       feedSign(feedNo) = -1\n",
      "       feedy(feedNo) = y1-1\n",
      "       feedcy(feedNo) = y1 - (feedLength(feedNo)+1)/2\n",
      "    else if(x1 == x2 .and. y1 == y2 .and. z1 < z2) then\n",
      "       feedAxis(feedNo) = 'z'\n",
      "       feedSign(feedNo) = +1\n",
      "       feedz(feedNo) = z1\n",
      "       feedcz(feedNo) = z1 + (feedLength(feedNo)-1)/2\n",
      "    else if(x1 == x2 .and. y1 == y2 .and. z1 > z2) then\n",
      "       feedAxis(feedNo) = 'z'\n",
      "       feedSign(feedNo) = -1\n",
      "       feedz(feedNo) = z1-1\n",
      "       feedcz(feedNo) = z1 - (feedLength(feedNo)+1)/2\n",
      "    else\n",
      "       stop 'Error. (setfeed)'\n",
      "    end if\n",
      "    do p=0, np-1\n",
      "       if(nzS(p) <= feedcz(feedNo) .and. feedcz(feedNo) <= nzE(p)) then\n",
      "          feedNode(feedNo) = p\n",
      "       end if\n",
      "    end do\n",
      "    feedR(feedNo) = fR\n",
      "    feedType(feedNo) = fType\n",
      "    feedTAU(feedNo) = fTAU\n",
      "    feedOMEGA(feedNo) = pi/fTAU\n",
      "    feedALPHA(feedNo) = (4.0d0/fTAU)**2\n",
      "    feedAMP(feedNo) = fAMP\n",
      "  end subroutine ARsetfeed\n",
      "  subroutine ASoCsetfeed(feedNo, x,y,z, &\n",
      "       & fLength, fDirection, fR, fType, fTAU, fAMP)\n",
      "    integer :: feedNo, x,y,z, fLength,fDirection\n",
      "    real*8 :: fR\n",
      "    integer:: fType\n",
      "    real*8 :: fTAU, fAMP\n",
      "    select case(fDirection)\n",
      "       case(-1)\n",
      "          call setfeed(feedNo, x+1,y,z, x+1-fLength,y,z, fR, fType, fTAU, fAMP)\n",
      "       case(1)\n",
      "          call setfeed(feedNo, x+1-fLength,y,z, x+1,y,z, fR, fType, fTAU, fAMP)\n",
      "       case(-2)\n",
      "          call setfeed(feedNo, x,y+1,z, x,y+1-fLength,z, fR, fType, fTAU, fAMP)\n",
      "       case(2)\n",
      "          call setfeed(feedNo, x,y+1-fLength,z, x,y+1,z, fR, fType, fTAU, fAMP)\n",
      "       case(-3)\n",
      "          call setfeed(feedNo, x,y,z+1, x,y,z+1-fLength, fR, fType, fTAU, fAMP)\n",
      "       case(3)\n",
      "          call setfeed(feedNo, x,y,z+1-fLength, x,y,z+1, fR, fType, fTAU, fAMP)\n",
      "       case default\n",
      "          stop 'Error. (ASoCsetfeed)'\n",
      "    end select\n",
      "  end subroutine ASoCsetfeed\n",
      "  subroutine ARsetline(materialID, x1, y1, z1, x2, y2, z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i\n",
      "    \n",
      "    if ((x2 > x1) .and. (y1 == y2) .and. (z1 == z2)) then\n",
      "       if((nzS(id) <= z1) .and. (z1 <= nzE(id))) then\n",
      "          IDEx(x1:x2-1,y1,z1) = materialID\n",
      "       endif\n",
      "    else if ((x1 == x2) .and. (y2 > y1) .and. (z1 == z2)) then\n",
      "       if((nzS(id) <= z1) .and. (z1 <= nzE(id))) then\n",
      "          IDEy(x1,y1:y2-1,z1) = materialID\n",
      "       endif\n",
      "    else if ((x1 == x2) .and. (y1 == y2) .and. (z2 > z1)) then\n",
      "       do i=z1, z2-1\n",
      "          if((nzS(id) <= i) .and. (i <= nzE(id))) then\n",
      "             IDEz(x1,y1,i) = materialID\n",
      "          endif\n",
      "       enddo\n",
      "    else\n",
      "       stop 'Error. (setline)'\n",
      "    endif\n",
      "  end subroutine ARsetline\n",
      "  subroutine ASoCsetline(materialID, x1, y1, z1, x2, y2, z2, axis)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: axis\n",
      "    select case(axis)\n",
      "    case(1)\n",
      "       call setline(materialID, x1, y1, z1, x2+1, y2, z2)\n",
      "    case(2)\n",
      "       call setline(materialID, x1, y1, z1, x2, y2+1, z2)\n",
      "    case(3)\n",
      "       call setline(materialID, x1, y1, z1, x2, y2, z2+1)\n",
      "    case default\n",
      "       stop 'Error. (ASoCsetline)'\n",
      "    endselect\n",
      "  end subroutine ASoCsetline\n",
      "  subroutine ARsetplane(materialID, x1, y1, z1, x2, y2, z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i\n",
      "    if ((x2 > x1) .and. (y2 > y1) .and. (z1 == z2)) then\n",
      "       do i = x1, x2\n",
      "          call setline(materialID, i, y1, z1, i, y2, z2)\n",
      "       enddo\n",
      "       do i = y1, y2\n",
      "          call setline(materialID, x1, i, z1, x2, i, z2)\n",
      "       enddo\n",
      "    else if ((x1 == x2) .and. (y2 > y1) .and. (z2 > z1)) then\n",
      "       do i = y1, y2\n",
      "          call setline(materialID, x1, i, z1, x2, i, z2)\n",
      "       enddo\n",
      "       do i = z1, z2\n",
      "          call setline(materialID, x1, y1, i, x2, y2, i)\n",
      "       enddo\n",
      "    else if ((x2 > x1) .and. (y1 == y2) .and. (z2 > z1)) then\n",
      "       do i = z1, z2\n",
      "          call setline(materialID, x1, y1, i, x2, y2, i)\n",
      "       enddo\n",
      "       do i = x1, x2\n",
      "          call setline(materialID, i, y1, z1, i, y2, z2)\n",
      "       enddo\n",
      "    else\n",
      "       stop 'Error. (setplane)'\n",
      "    endif\n",
      "  end subroutine ARsetplane\n",
      "  subroutine ASoCsetplane(materialID, x1,y1,z1, x2,y2,z2, planeFlag)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: planeFlag\n",
      "    select case(planeFlag)\n",
      "    case(1)\n",
      "       call setplane(materialID, x1, y1, z1, x2, y2+1, z2+1)\n",
      "    case(2)\n",
      "       call setplane(materialID, x1, y1, z1, x2+1, y2, z2+1)\n",
      "    case(3)\n",
      "       call setplane(materialID, x1, y1, z1, x2+1, y2+1, z2)\n",
      "    case default\n",
      "       stop 'Error. (ASoCsetplane)'\n",
      "    endselect\n",
      "  end subroutine ASoCsetplane\n",
      "  subroutine setplane2(materialID, x1, y1, z1, x2, y2, z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i\n",
      "    \n",
      "    if ((x2 > x1) .and. (y2 > y1) .and. (z1 == z2)) then\n",
      "       do i = x1+1, x2-1\n",
      "          call setline(materialID, i, y1, z1, i, y2, z2)\n",
      "       enddo\n",
      "       do i = y1+1, y2-1\n",
      "          call setline(materialID, x1, i, z1, x2, i, z2)\n",
      "       enddo\n",
      "    else if ((x1 == x2) .and. (y2 > y1) .and. (z2 > z1)) then\n",
      "       do i = y1+1, y2-1\n",
      "          call setline(materialID, x1, i, z1, x2, i, z2)\n",
      "       enddo\n",
      "       do i = z1+1, z2-1\n",
      "          call setline(materialID, x1, y1, i, x2, y2, i)\n",
      "       enddo\n",
      "    else if ((x2 > x1) .and. (y1 == y2) .and. (z2 > z1)) then\n",
      "       do i = z1+1, z2-1\n",
      "          call setline(materialID, x1, y1, i, x2, y2, i)\n",
      "       enddo\n",
      "       do i = x1+1, x2-1\n",
      "          call setline(materialID, i, y1, z1, i, y2, z2)\n",
      "       enddo\n",
      "    else\n",
      "       stop 'Error. (setplane2)'\n",
      "    endif\n",
      "  end subroutine setplane2\n",
      "  subroutine setbox(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    \n",
      "    if(ModelingMode == 0) then\n",
      "       call ARsetbox(materialID, x1,y1,z1, x2,y2,z2)\n",
      "    else if(ModelingMode == 1) then\n",
      "       call ASoCsetbox(materialID, x1,y1,z1, x2,y2,z2)\n",
      "    end if\n",
      "  end subroutine setbox\n",
      "  subroutine ARsetbox(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i\n",
      "    if ((x2 > x1) .and. (y2 > y1) .and. (z2 > z1)) then\n",
      "       do i = x1, x2\n",
      "          call setplane(materialID, i,y1,z1, i,y2,z2)\n",
      "       enddo\n",
      "       do i = y1, y2\n",
      "          call setplane(materialID, x1,i,z1, x2,i,z2)\n",
      "       enddo\n",
      "       do i = z1, z2\n",
      "          call setplane(materialID, x1,y1,i, x2,y2,i)\n",
      "       enddo\n",
      "    else\n",
      "       stop 'Error. (setbox)'\n",
      "    endif\n",
      "  end subroutine ARsetbox\n",
      "  subroutine ASoCsetbox(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    if ((x2 >= x1) .and. (y2 >= y1) .and. (z2 >= z1)) then\n",
      "       call ARsetbox(materialID, x1,y1,z1 , x2+1,y2+1,z2+1)\n",
      "    else\n",
      "       stop 'Error. (ASoCsetbox)'\n",
      "    endif\n",
      "  end subroutine ASoCsetbox\n",
      "  subroutine setbox2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i\n",
      "    if ((x2 > x1) .and. (y2 > y1) .and. (z2 > z1)) then\n",
      "       do i = x1+1, x2-1\n",
      "          call setplane2(materialID, i,y1,z1, i,y2,z2)\n",
      "       enddo\n",
      "       do i = y1+1, y2-1\n",
      "          call setplane2(materialID, x1,i,z1, x2,i,z2)\n",
      "       enddo\n",
      "       do i = z1+1, z2-1\n",
      "          call setplane2(materialID, x1,y1,i, x2,y2,i)\n",
      "       enddo\n",
      "    else\n",
      "       stop 'Error. (setbox2)'\n",
      "    endif\n",
      "  end subroutine setbox2\n",
      "  subroutine setoval(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    if ((x2 > x1) .and. (y2 > y1) .and. (z1 == z2)) then\n",
      "       call setxyoval(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else if ((x1 == x2) .and. (y2 > y1) .and. (z2 > z1)) then\n",
      "       call setyzoval(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else if ((x2 > x1) .and. (y1 == y2) .and. (z2 > z1)) then\n",
      "       call setzxoval(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else\n",
      "       stop 'Error. (setoval)'\n",
      "    endif\n",
      "  end subroutine setoval\n",
      "  subroutine setxyoval(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, xc, yc\n",
      "    real*8 :: y(x1:x2), x(y1:y2)\n",
      "    a = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    b = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    do j=y1, y2\n",
      "       x(j) = -a*sqrt(1.0d0 - (dble(j-yc)**2)/dble(b**2)) +xc\n",
      "    enddo\n",
      "    do i=x1, x2\n",
      "       y(i) = -b*sqrt(1.0d0 - (dble(i-xc)**2)/dble(a**2)) +yc\n",
      "    enddo\n",
      "    do j=y1, int(yc - 0.01d0)\n",
      "       do i=x1, int(xc - 0.01d0)\n",
      "          if(x(j) < i)then\n",
      "             ! OK\n",
      "             call setplane(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "             exit\n",
      "          else if((i < x(j)) .and. (x(j) < i+1)) then\n",
      "             if((j < y(i)) .and. y(i) < j+1) then\n",
      "           ! OK\n",
      "                call setplane(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                exit\n",
      "             else\n",
      "                ! [/]type\n",
      "                if(((dble(i+1)-x(j))+(dble(i+1)-x(j+1))) > 1.0d0) then\n",
      "                   call setplane(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(y(i) < j+1) then\n",
      "                ![/] type\n",
      "                if(((dble(j+1)-y(i))+(dble(j+1)-y(i+1))) > 1.0d0) then\n",
      "                   call setplane(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setxyoval\n",
      "  subroutine setyzoval(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, yc, zc\n",
      "    real*8 :: y(z1:z2), z(y1:y2)\n",
      "    a = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    b = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    do j=z1, z2\n",
      "       y(j) = -a*sqrt(1.0d0 - (dble(j-zc)**2)/dble(b**2)) +yc\n",
      "    enddo\n",
      "    do i=y1, y2\n",
      "       z(i) = -b*sqrt(1.0d0 - (dble(i-yc)**2)/dble(a**2)) +zc\n",
      "    enddo\n",
      "    do j=z1, int(zc - 0.01d0)\n",
      "       do i=y1, int(yc - 0.01d0)\n",
      "          if(y(j) < i)then\n",
      "             call setplane(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "             exit\n",
      "          else if((i < y(j)) .and. (y(j) < i+1)) then\n",
      "             if((j < z(i)) .and. z(i) < j+1) then\n",
      "                call setplane(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                exit\n",
      "             else\n",
      "                if(((dble(i+1)-y(j))+(dble(i+1)-y(j+1))) > 1.0d0) then\n",
      "                   call setplane(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(z(i) < j+1) then\n",
      "                if(((dble(j+1)-z(i))+(dble(j+1)-z(i+1))) > 1.0d0) then\n",
      "                   call setplane(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setyzoval\n",
      "  subroutine setzxoval(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, zc, xc\n",
      "    real*8 :: z(x1:x2), x(z1:z2)\n",
      "    a = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    b = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    do j=x1, x2\n",
      "       z(j) = -a*sqrt(1.0d0 - (dble(j-xc)**2)/dble(b**2)) +zc\n",
      "    enddo\n",
      "    do i=z1, z2\n",
      "       x(i) = -b*sqrt(1.0d0 - (dble(i-zc)**2)/dble(a**2)) +xc\n",
      "    enddo\n",
      "    do j=x1, int(xc - 0.01d0)\n",
      "       do i=z1, int(zc - 0.01d0)\n",
      "          if(z(j) < i)then\n",
      "             call setplane(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "             exit\n",
      "          else if((i < z(j)) .and. (z(j) < i+1)) then\n",
      "             if((j < x(i)) .and. x(i) < j+1) then\n",
      "                call setplane(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                exit\n",
      "             else\n",
      "                if(((dble(i+1)-z(j))+(dble(i+1)-z(j+1))) > 1.0d0) then\n",
      "                   call setplane(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(x(i) < j+1) then\n",
      "                if(((dble(j+1)-x(i))+(dble(j+1)-x(i+1))) > 1.0d0) then\n",
      "                   call setplane(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setzxoval\n",
      "  \n",
      "  subroutine setovalCP(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    if ((x2 > x1) .and. (y2 > y1) .and. (z1 == z2)) then\n",
      "       call setxyovalCP(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else if ((x1 == x2) .and. (y2 > y1) .and. (z2 > z1)) then\n",
      "       call setyzovalCP(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else if ((x2 > x1) .and. (y1 == y2) .and. (z2 > z1)) then\n",
      "       call setzxovalCP(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else\n",
      "       stop 'Error. (setovalCP)'\n",
      "    endif\n",
      "  end subroutine setovalCP\n",
      "  subroutine setxyovalCP(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j, i2, j2\n",
      "    real*8 :: a, b, xc, yc\n",
      "    real*8 :: y(x1:x2), x(y1:y2)\n",
      "    a = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    b = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    do j=y1, y2\n",
      "       x(j) = -a*sqrt(1.0d0 - (dble(j-yc)**2)/dble(b**2)) +xc\n",
      "    enddo\n",
      "    do i=x1, x2\n",
      "       y(i) = -b*sqrt(1.0d0 - (dble(i-xc)**2)/dble(a**2)) +yc\n",
      "    enddo\n",
      "    do j=y1, int(yc - 0.01d0)\n",
      "       j2 = nint(2.0d0*yc) - j - 1\n",
      "       do i=x1, int(xc - 0.01d0)\n",
      "          i2 = nint(2.0d0*xc) - i - 1\n",
      "          if(x(j) < i)then\n",
      "             ! OK\n",
      "             call setplane(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "             exit\n",
      "          else if((i < x(j)) .and. (x(j) < i+1)) then\n",
      "             if((j < y(i)) .and. y(i) < j+1) then\n",
      "           !   ____\n",
      "                ! $(B!?(B    |\n",
      "                ! |     | pattern\n",
      "                ! |____M|\n",
      "                !\n",
      "                call setCP(materialID, i,j,z1, &\n",
      "                     & x(j)-dble(i), y(i)-dble(j), 1.0d0, &\n",
      "                     & 0.0d0, 0.0d0, 1.0d0, &\n",
      "                     & (x(j)-dble(i))*(y(i)-dble(j))*0.5d0, 3)\n",
      "                call setCP(materialID, i,j2,z1, &\n",
      "                     & 0.0d0, y(i)-dble(j), 1.0d0, &\n",
      "                     & x(j)-dble(i), 0.0d0, 1.0d0, &\n",
      "                     & (x(j)-dble(i))*(y(i)-dble(j))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j,z1, &\n",
      "                     & x(j)-dble(i), 0.0d0, 1.0d0, &\n",
      "                     & 0.0d0, y(i)-dble(j), 1.0d0, &\n",
      "                     & (x(j)-dble(i))*(y(i)-dble(j))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j2,z1, &\n",
      "                     & 0.0d0, 0.0d0, 1.0d0, &\n",
      "                     & x(j)-dble(i), y(i)-dble(j), 1.0d0, &\n",
      "                     & (x(j)-dble(i))*(y(i)-dble(j))*0.5d0, 3)\n",
      "                cycle\n",
      "             else\n",
      "                !  _____\n",
      "                ! |   / |\n",
      "                ! |  /  | pattern\n",
      "                ! |_/___|\n",
      "                !\n",
      "                call setCP(materialID, i,j,z1, &\n",
      "                     & x(j)-dble(i), 1.0d0, 1.0d0, &\n",
      "                     & x(j+1)-dble(i), 0.0d0, 1.0d0, &\n",
      "                     & (x(j)-dble(i)+x(j+1)-dble(i))*0.5d0, 3)\n",
      "                call setCP(materialID, i,j2,z1, &\n",
      "                     & x(j+1)-dble(i), 1.0d0, 1.0d0, &\n",
      "                     & x(j)-dble(i), 0.0d0, 1.0d0, &\n",
      "                     & (x(j)-dble(i)+x(j+1)-dble(i))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j,z1, &\n",
      "                     & x(j)-dble(i), 0.0d0, 1.0d0, &\n",
      "                     & x(j+1)-dble(i), 1.0d0, 1.0d0, &\n",
      "                     & (x(j)-dble(i)+x(j+1)-dble(i))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j2,z1, &\n",
      "                     & x(j+1)-dble(i), 0.0d0, 1.0d0, &\n",
      "                     & x(j)-dble(i), 1.0d0, 1.0d0, &\n",
      "                     & (x(j)-dble(i)+x(j+1)-dble(i))*0.5d0, 3)\n",
      "                cycle\n",
      "             endif\n",
      "          else\n",
      "             if(y(i) < j+1) then\n",
      "                !  ______\n",
      "                ! |    __|\n",
      "                ! |__$(B!?(B  | pattern\n",
      "                ! |______|\n",
      "                !\n",
      "                call setCP(materialID, i,j,z1, &\n",
      "                     & 1.0d0, y(i)-dble(j), 1.0d0, &\n",
      "                     & 0.0d0, y(i+1)-dble(j), 1.0d0, &\n",
      "                     & (y(i)-dble(j)+y(i+1)-dble(j))*0.5d0, 3)\n",
      "                call setCP(materialID, i,j2,z1, &\n",
      "                     & 0.0d0, y(i)-dble(j), 1.0d0, &\n",
      "                     & 1.0d0, y(i+1)-dble(j), 1.0d0, &\n",
      "                     & (y(i)-dble(j)+y(i+1)-dble(j))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j,z1, &\n",
      "                     & 1.0d0, y(i+1)-dble(j), 1.0d0, &\n",
      "                     & 0.0d0, y(i)-dble(j), 1.0d0, &\n",
      "                     & (y(i)-dble(j)+y(i+1)-dble(j))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j2,z1, &\n",
      "                     & 0.0d0, y(i+1)-dble(j), 1.0d0, &\n",
      "                     & 1.0d0, y(i)-dble(j), 1.0d0, &\n",
      "                     & (y(i)-dble(j)+y(i+1)-dble(j))*0.5d0, 3)\n",
      "                cycle\n",
      "             else if(y(i+1) < j+1) then\n",
      "                !  ______\n",
      "                ! |Air   |\n",
      "                ! |      | pattern\n",
      "                ! |____$(B!?(B\n",
      "                ! \n",
      "                call setCP(materialID, i,j,z1, &\n",
      "                     & 1.0d0, 1.0d0, 1.0d0, &\n",
      "                     & x(j+1)-dble(i), y(i+1)-dble(j), 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-x(j+1))*(dble(j+1)-y(i+1))*0.5d0, 3)\n",
      "                call setCP(materialID, i,j2,z1, &\n",
      "                     & x(j+1)-dble(i), 1.0d0, 1.0d0, &\n",
      "                     & 1.0d0, y(i+1)-dble(j), 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-x(j+1))*(dble(j+1)-y(i+1))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j,z1, &\n",
      "                     & 1.0d0, y(i+1)-dble(j), 1.0d0, &\n",
      "                     & x(j+1)-dble(i), 1.0d0, 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-x(j+1))*(dble(j+1)-y(i+1))*0.5d0, 3)\n",
      "                call setCP(materialID, i2,j2,z1, &\n",
      "                     & x(j+1)-dble(i), y(i+1)-dble(j), 1.0d0, &\n",
      "                     & 1.0d0, 1.0d0, 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-x(j+1))*(dble(j+1)-y(i+1))*0.5d0, 3)\n",
      "                cycle\n",
      "             else\n",
      "                ! out of circle\n",
      "                cycle\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setxyovalCP\n",
      "  subroutine setyzovalCP(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j, i2, j2\n",
      "    real*8 :: a, b, yc, zc\n",
      "    real*8 :: y(z1:z2), z(y1:y2)\n",
      "    a = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    b = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    do j=z1, z2\n",
      "       y(j) = -a*sqrt(1.0d0 - (dble(j-zc)**2)/dble(b**2)) +yc\n",
      "    enddo\n",
      "    do i=y1, y2\n",
      "       z(i) = -b*sqrt(1.0d0 - (dble(i-yc)**2)/dble(a**2)) +zc\n",
      "    enddo\n",
      "    do j=z1, int(zc - 0.01d0)\n",
      "       j2 = nint(2.0d0*zc) - j - 1\n",
      "       do i=y1, int(yc - 0.01d0)\n",
      "          i2 = nint(2.0d0*yc) - i - 1\n",
      "          if(y(j) < i)then\n",
      "             call setplane(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "             exit\n",
      "          else if((i < y(j)) .and. (y(j) < i+1)) then\n",
      "             if((j < z(i)) .and. z(i) < j+1) then\n",
      "           !   ____\n",
      "                ! $(B!?(B    |\n",
      "                ! |     | pattern\n",
      "                ! |____M|\n",
      "                !\n",
      "                call setCP(materialID, x1,i,j, &\n",
      "                     & 1.0d0, y(j)-dble(i), z(i)-dble(j), &\n",
      "                     & 1.0d0, 0.0d0, 0.0d0, &\n",
      "                     & (y(j)-dble(i))*(z(i)-dble(j))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i,j2, &\n",
      "                     & 1.0d0, 0.0d0, z(i)-dble(j), &\n",
      "                     & 1.0d0, y(j)-dble(i), 0.0d0, &\n",
      "                     & (y(j)-dble(i))*(z(i)-dble(j))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j, &\n",
      "                     & 1.0d0, y(j)-dble(i), 0.0d0, &\n",
      "                     & 1.0d0, 0.0d0, z(i)-dble(j), &\n",
      "                     & (y(j)-dble(i))*(z(i)-dble(j))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j2, &\n",
      "                     & 1.0d0, 0.0d0, 0.0d0, &\n",
      "                     & 1.0d0, y(j)-dble(i), z(i)-dble(j), &\n",
      "                     & (y(j)-dble(i))*(z(i)-dble(j))*0.5d0, 1)\n",
      "                cycle\n",
      "             else\n",
      "                !  _____\n",
      "                ! |   / |\n",
      "                ! |  /  | pattern\n",
      "                ! |_/___|\n",
      "                !\n",
      "                call setCP(materialID, x1,i,j, &\n",
      "                     & 1.0d0, y(j)-dble(i), 1.0d0, &\n",
      "                     & 1.0d0, y(j+1)-dble(i), 0.0d0, &\n",
      "                     & (y(j)-dble(i)+y(j+1)-dble(i))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i,j2, &\n",
      "                     & 1.0d0, y(j+1)-dble(i), 1.0d0, &\n",
      "                     & 1.0d0, y(j)-dble(i), 0.0d0, &\n",
      "                     & (y(j)-dble(i)+y(j+1)-dble(i))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j, &\n",
      "                     & 1.0d0, y(j)-dble(i), 0.0d0, &\n",
      "                     & 1.0d0, y(j+1)-dble(i), 1.0d0, &\n",
      "                     & (y(j)-dble(i)+y(j+1)-dble(i))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j2, &\n",
      "                     & 1.0d0, y(j+1)-dble(i), 0.0d0, &\n",
      "                     & 1.0d0, y(j)-dble(i), 1.0d0, &\n",
      "                     & (y(j)-dble(i)+y(j+1)-dble(i))*0.5d0, 1)\n",
      "                cycle\n",
      "             endif\n",
      "          else\n",
      "             if(z(i) < j+1) then\n",
      "                !  ______\n",
      "                ! |    __|\n",
      "                ! |__$(B!?(B  | pattern\n",
      "                ! |______|\n",
      "                !\n",
      "                call setCP(materialID, x1,i,j, &\n",
      "                     & 1.0d0, 1.0d0, z(i)-dble(j), &\n",
      "                     & 1.0d0, 0.0d0, z(i+1)-dble(j), &\n",
      "                     & (z(i)-dble(j)+z(i+1)-dble(j))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i,j2, &\n",
      "                     & 1.0d0, 0.0d0, z(i)-dble(j), &\n",
      "                     & 1.0d0, 1.0d0, z(i+1)-dble(j), &\n",
      "                     & (z(i)-dble(j)+z(i+1)-dble(j))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j, &\n",
      "                     & 1.0d0, 1.0d0, z(i+1)-dble(j), &\n",
      "                     & 1.0d0, 0.0d0, z(i)-dble(j), &\n",
      "                     & (z(i)-dble(j)+z(i+1)-dble(j))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j2, &\n",
      "                     & 1.0d0, 0.0d0, z(i+1)-dble(j), &\n",
      "                     & 1.0d0, 1.0d0, z(i)-dble(j), &\n",
      "                     & (z(i)-dble(j)+z(i+1)-dble(j))*0.5d0, 1)\n",
      "                cycle\n",
      "             else if(z(i+1) < j+1) then\n",
      "                !  ______\n",
      "                ! |Air   |\n",
      "                ! |      | pattern\n",
      "                ! |____$(B!?(B\n",
      "                ! \n",
      "                call setCP(materialID, x1,i,j, &\n",
      "                     & 1.0d0, 1.0d0, 1.0d0, &\n",
      "                     & 1.0d0, y(j+1)-dble(i), z(i+1)-dble(j), &\n",
      "                     & 1.0d0-(dble(i+1)-y(j+1))*(dble(j+1)-z(i+1))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i,j2, &\n",
      "                     & 1.0d0, y(j+1)-dble(i), 1.0d0, &\n",
      "                     & 1.0d0, 1.0d0, z(i+1)-dble(j), &\n",
      "                     & 1.0d0-(dble(i+1)-y(j+1))*(dble(j+1)-z(i+1))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j, &\n",
      "                     & 1.0d0, 1.0d0, z(i+1)-dble(j), &\n",
      "                     & 1.0d0, y(j+1)-dble(i), 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-y(j+1))*(dble(j+1)-z(i+1))*0.5d0, 1)\n",
      "                call setCP(materialID, x1,i2,j2, &\n",
      "                     & 1.0d0, y(j+1)-dble(i), z(i+1)-dble(j), &\n",
      "                     & 1.0d0, 1.0d0, 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-y(j+1))*(dble(j+1)-z(i+1))*0.5d0, 1)\n",
      "                cycle\n",
      "             else\n",
      "                ! out of circle\n",
      "                cycle\n",
      "             end if\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setyzovalCP\n",
      "  subroutine setzxovalCP(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j, i2, j2\n",
      "    real*8 :: a, b, zc, xc\n",
      "    real*8 :: z(x1:x2), x(z1:z2)\n",
      "    a = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    b = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    do j=x1, x2\n",
      "       z(j) = -a*sqrt(1.0d0 - (dble(j-xc)**2)/dble(b**2)) +zc\n",
      "    enddo\n",
      "    do i=z1, z2\n",
      "       x(i) = -b*sqrt(1.0d0 - (dble(i-zc)**2)/dble(a**2)) +xc\n",
      "    enddo\n",
      "    do j=x1, int(xc - 0.01d0)\n",
      "       j2 = nint(2.0d0*xc) - j - 1\n",
      "       do i=z1, int(zc - 0.01d0)\n",
      "          i2 = nint(2.0d0*zc) - i - 1\n",
      "          if(z(j) < i)then\n",
      "             call setplane(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "             exit\n",
      "          else if((i < z(j)) .and. (z(j) < i+1)) then\n",
      "             if((j < x(i)) .and. x(i) < j+1) then\n",
      "           !   ____\n",
      "                ! $(B!?(B    |\n",
      "                ! |     | pattern\n",
      "                ! |____M|\n",
      "                !\n",
      "                call setCP(materialID, j,y1,i, &\n",
      "                     & x(i)-dble(j), 1.0d0, z(j)-dble(i), &\n",
      "                     & 0.0d0, 1.0d0, 0.0d0, &\n",
      "                     & (z(j)-dble(i))*(x(i)-dble(j))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i, &\n",
      "                     & x(i)-dble(j), 1.0d0, 0.0d0, &\n",
      "                     & 0.0d0, 1.0d0, z(j)-dble(i), &\n",
      "                     & (z(j)-dble(i))*(x(i)-dble(j))*0.5d0, 2)\n",
      "                call setCP(materialID, j,y1,i2, &\n",
      "                     & 0.0d0, 1.0d0, z(j)-dble(i), &\n",
      "                     & x(i)-dble(j), 1.0d0, 0.0d0, &\n",
      "                     & (z(j)-dble(i))*(x(i)-dble(j))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i2, &\n",
      "                     & 0.0d0, 1.0d0, 0.0d0, &\n",
      "                     & x(i)-dble(j), 1.0d0, z(j)-dble(i), &\n",
      "                     & (z(j)-dble(i))*(x(i)-dble(j))*0.5d0, 2)\n",
      "                cycle\n",
      "             else\n",
      "                !  _____\n",
      "                ! |   / |\n",
      "                ! |  /  | pattern\n",
      "                ! |_/___|\n",
      "                !\n",
      "                call setCP(materialID, j,y1,i, &\n",
      "                     & 1.0d0, 1.0d0, z(j)-dble(i), &\n",
      "                     & 0.0d0, 1.0d0, z(j+1)-dble(i), &\n",
      "                     & (z(j)-dble(i)+z(j+1)-dble(i))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i, &\n",
      "                     & 1.0d0, 1.0d0, z(j+1)-dble(i), &\n",
      "                     & 0.0d0, 1.0d0, z(j)-dble(i), &\n",
      "                     & (z(j)-dble(i)+z(j+1)-dble(i))*0.5d0, 2)\n",
      "                call setCP(materialID, j,y1,i2, &\n",
      "                     & 0.0d0, 1.0d0, z(j)-dble(i), &\n",
      "                     & 1.0d0, 1.0d0, z(j+1)-dble(i), &\n",
      "                     & (z(j)-dble(i)+z(j+1)-dble(i))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i2, &\n",
      "                     & 0.0d0, 1.0d0, z(j+1)-dble(i), &\n",
      "                     & 1.0d0, 1.0d0, z(j)-dble(i), &\n",
      "                     & (z(j)-dble(i)+z(j+1)-dble(i))*0.5d0, 2)\n",
      "                cycle\n",
      "             endif\n",
      "          else\n",
      "             if(x(i) < j+1) then\n",
      "                !  ______\n",
      "                ! |    __|\n",
      "                ! |__$(B!?(B  | pattern\n",
      "                ! |______|\n",
      "                !\n",
      "                call setCP(materialID, j,y1,i, &\n",
      "                     & x(i)-dble(j),1.0d0, 1.0d0, &\n",
      "                     & x(i+1)-dble(j), 1.0d0, 0.0d0, &\n",
      "                     & (x(i)-dble(j)+x(i+1)-dble(j))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i, &\n",
      "                     & x(i)-dble(j),1.0d0, 0.0d0, &\n",
      "                     & x(i+1)-dble(j), 1.0d0, 1.0d0, &\n",
      "                     & (x(i)-dble(j)+x(i+1)-dble(j))*0.5d0, 2)\n",
      "                call setCP(materialID, j,y1,i2, &\n",
      "                     & x(i+1)-dble(j),1.0d0, 1.0d0, &\n",
      "                     & x(i)-dble(j), 1.0d0, 0.0d0, &\n",
      "                     & (x(i)-dble(j)+x(i+1)-dble(j))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i2, &\n",
      "                     & x(i+1)-dble(j),1.0d0, 0.0d0, &\n",
      "                     & x(i)-dble(j), 1.0d0, 1.0d0, &\n",
      "                     & (x(i)-dble(j)+x(i+1)-dble(j))*0.5d0, 2)\n",
      "                cycle\n",
      "             else if(x(i+1) < j+1) then\n",
      "                !  ______\n",
      "                ! |Air   |\n",
      "                ! |      | pattern\n",
      "                ! |____$(B!?(B\n",
      "                ! \n",
      "                call setCP(materialID, j,y1,i, &\n",
      "                     & 1.0d0, 1.0d0, 1.0d0, &\n",
      "                     & x(i+1)-dble(j),1.0d0, z(j+1)-dble(i), &\n",
      "                     & 1.0d0-(dble(i+1)-z(j+1))*(dble(j+1)-x(i+1))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i, &\n",
      "                     & 1.0d0, 1.0d0, z(j+1)-dble(i), &\n",
      "                     & x(i+1)-dble(j),1.0d0, 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-z(j+1))*(dble(j+1)-x(i+1))*0.5d0, 2)\n",
      "                call setCP(materialID, j,y1,i2, &\n",
      "                     & x(i+1)-dble(j), 1.0d0, 1.0d0, &\n",
      "                     & 1.0d0, 1.0d0, z(j+1)-dble(i), &\n",
      "                     & 1.0d0-(dble(i+1)-z(j+1))*(dble(j+1)-x(i+1))*0.5d0, 2)\n",
      "                call setCP(materialID, j2,y1,i2, &\n",
      "                     & x(i+1)-dble(j), 1.0d0, z(j+1)-dble(i), &\n",
      "                     & 1.0d0,1.0d0, 1.0d0, &\n",
      "                     & 1.0d0-(dble(i+1)-z(j+1))*(dble(j+1)-x(i+1))*0.5d0, 2)\n",
      "                cycle\n",
      "             else\n",
      "                ! out of circle\n",
      "                cycle\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setzxovalCP\n",
      "  subroutine setoval2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    if ((x2 > x1) .and. (y2 > y1) .and. (z1 == z2)) then\n",
      "       call setxyoval2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else if ((x1 == x2) .and. (y2 > y1) .and. (z2 > z1)) then\n",
      "       call setyzoval2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else if ((x2 > x1) .and. (y1 == y2) .and. (z2 > z1)) then\n",
      "       call setzxoval2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    else\n",
      "       stop 'Error. (setoval2)'\n",
      "    endif\n",
      "  end subroutine setoval2\n",
      "  subroutine setxyoval2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, xc, yc\n",
      "    real*8 :: y(x1:x2), x(y1:y2)\n",
      "    a = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    b = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    do j=y1, y2\n",
      "       x(j) = -a*sqrt(1.0d0 - (dble(j-yc)**2)/dble(b**2)) +xc\n",
      "    enddo\n",
      "    do i=x1, x2\n",
      "       y(i) = -b*sqrt(1.0d0 - (dble(i-xc)**2)/dble(a**2)) +yc\n",
      "    enddo\n",
      "    do j=y1, int(yc - 0.01d0)\n",
      "       do i=x1, int(xc - 0.01d0)\n",
      "          if(x(j) < i)then\n",
      "             ! OK\n",
      "             call setplane2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "             exit\n",
      "          else if((i < x(j)) .and. (x(j) < i+1)) then\n",
      "             if((j < y(i)) .and. y(i) < j+1) then\n",
      "           ! OK\n",
      "                call setplane2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                exit\n",
      "             else\n",
      "                ! [/]type\n",
      "                if(((dble(i+1)-x(j))+(dble(i+1)-x(j+1))) > 1.0d0) then\n",
      "                   call setplane2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(y(i) < j+1) then\n",
      "                ![/] type\n",
      "                if(((dble(j+1)-y(i))+(dble(j+1)-y(i+1))) > 1.0d0) then\n",
      "                   call setplane2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setxyoval2\n",
      "  subroutine setyzoval2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, yc, zc\n",
      "    real*8 :: y(z1:z2), z(y1:y2)\n",
      "    a = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    b = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    do j=z1, z2\n",
      "       y(j) = -a*sqrt(1.0d0 - (dble(j-zc)**2)/dble(b**2)) +yc\n",
      "    enddo\n",
      "    do i=y1, y2\n",
      "       z(i) = -b*sqrt(1.0d0 - (dble(i-yc)**2)/dble(a**2)) +zc\n",
      "    enddo\n",
      "    do j=z1, int(zc - 0.01d0)\n",
      "       do i=y1, int(yc - 0.01d0)\n",
      "          if(y(j) < i)then\n",
      "             call setplane2(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "             exit\n",
      "          else if((i < y(j)) .and. (y(j) < i+1)) then\n",
      "             if((j < z(i)) .and. z(i) < j+1) then\n",
      "                call setplane2(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                exit\n",
      "             else\n",
      "                if(((dble(i+1)-y(j))+(dble(i+1)-y(j+1))) > 1.0d0) then\n",
      "                   call setplane2(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(z(i) < j+1) then\n",
      "                if(((dble(j+1)-z(i))+(dble(j+1)-z(i+1))) > 1.0d0) then\n",
      "                   call setplane2(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setyzoval2\n",
      "  subroutine setzxoval2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, zc, xc\n",
      "    real*8 :: z(x1:x2), x(z1:z2)\n",
      "    a = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    b = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    do j=x1, x2\n",
      "       z(j) = -a*sqrt(1.0d0 - (dble(j-xc)**2)/dble(b**2)) +zc\n",
      "    enddo\n",
      "    do i=z1, z2\n",
      "       x(i) = -b*sqrt(1.0d0 - (dble(i-zc)**2)/dble(a**2)) +xc\n",
      "    enddo\n",
      "    do j=x1, int(xc - 0.01d0)\n",
      "       do i=z1, int(zc - 0.01d0)\n",
      "          if(z(j) < i)then\n",
      "             call setplane2(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "             exit\n",
      "          else if((i < z(j)) .and. (z(j) < i+1)) then\n",
      "             if((j < x(i)) .and. x(i) < j+1) then\n",
      "                call setplane2(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                exit\n",
      "             else\n",
      "                if(((dble(i+1)-z(j))+(dble(i+1)-z(j+1))) > 1.0d0) then\n",
      "                   call setplane2(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(x(i) < j+1) then\n",
      "                if(((dble(j+1)-x(i))+(dble(j+1)-x(i+1))) > 1.0d0) then\n",
      "                   call setplane2(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setzxoval2\n",
      "  \n",
      "  subroutine setXY_Zcylinder(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, xc, yc\n",
      "    real*8 :: y(x1:x2), x(y1:y2)\n",
      "    a = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    b = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    do j=y1, y2\n",
      "       x(j) = -a*sqrt(1.0d0 - (dble(j-yc)**2)/dble(b**2)) +xc\n",
      "    enddo\n",
      "    do i=x1, x2\n",
      "       y(i) = -b*sqrt(1.0d0 - (dble(i-xc)**2)/dble(a**2)) +yc\n",
      "    enddo\n",
      "    do j=y1, int(yc - 0.01d0)\n",
      "       do i=x1, int(xc - 0.01d0)\n",
      "          if(x(j) < i)then\n",
      "             ! OK\n",
      "             call setbox(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "             exit\n",
      "          else if((i < x(j)) .and. (x(j) < i+1)) then\n",
      "             if((j < y(i)) .and. y(i) < j+1) then\n",
      "           ! OK\n",
      "                call setbox(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                exit\n",
      "             else\n",
      "                ! [/]type\n",
      "                if(((dble(i+1)-x(j))+(dble(i+1)-x(j+1))) > 1.0d0) then\n",
      "                   call setbox(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(y(i) < j+1) then\n",
      "                ![/] type\n",
      "                if(((dble(j+1)-y(i))+(dble(j+1)-y(i+1))) > 1.0d0) then\n",
      "                   call setbox(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setXY_Zcylinder\n",
      "  subroutine setYZ_Xcylinder(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, yc, zc\n",
      "    real*8 :: y(z1:z2), z(y1:y2)\n",
      "    a = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    b = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    do j=z1, z2\n",
      "       y(j) = -a*sqrt(1.0d0 - (dble(j-zc)**2)/dble(b**2)) +yc\n",
      "    enddo\n",
      "    do i=y1, y2\n",
      "       z(i) = -b*sqrt(1.0d0 - (dble(i-yc)**2)/dble(a**2)) +zc\n",
      "    enddo\n",
      "    do j=z1, int(zc - 0.01d0)\n",
      "       do i=y1, int(yc - 0.01d0)\n",
      "          if(y(j) < i)then\n",
      "             call setbox(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "             exit\n",
      "          else if((i < y(j)) .and. (y(j) < i+1)) then\n",
      "             if((j < z(i)) .and. z(i) < j+1) then\n",
      "                call setbox(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                exit\n",
      "             else\n",
      "                if(((dble(i+1)-y(j))+(dble(i+1)-y(j+1))) > 1.0d0) then\n",
      "                   call setbox(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(z(i) < j+1) then\n",
      "                if(((dble(j+1)-z(i))+(dble(j+1)-z(i+1))) > 1.0d0) then\n",
      "                   call setbox(materialID, x1,i,j , x2,y2-i+y1,z2-j+z1)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setYZ_Xcylinder\n",
      "  subroutine setZX_Ycylinder(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, zc, xc\n",
      "    real*8 :: z(x1:x2), x(z1:z2)\n",
      "    \n",
      "    a = dble(z2 - z1)*0.5d0*1.000001d0\n",
      "    b = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    zc = dble(z1 + z2)*0.5d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    \n",
      "    do j=x1, x2\n",
      "       z(j) = -a*sqrt(1.0d0 - (dble(j-xc)**2)/dble(b**2)) +zc\n",
      "    enddo\n",
      "    do i=z1, z2\n",
      "       x(i) = -b*sqrt(1.0d0 - (dble(i-zc)**2)/dble(a**2)) +xc\n",
      "    enddo\n",
      "    do j=x1, int(xc - 0.01d0)\n",
      "       do i=z1, int(zc - 0.01d0)\n",
      "          if(z(j) < i)then\n",
      "             call setbox(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "             exit\n",
      "          else if((i < z(j)) .and. (z(j) < i+1)) then\n",
      "             if((j < x(i)) .and. x(i) < j+1) then\n",
      "                call setbox(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                exit\n",
      "             else\n",
      "                if(((dble(i+1)-z(j))+(dble(i+1)-z(j+1))) > 1.0d0) then\n",
      "                   call setbox(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(x(i) < j+1) then\n",
      "                if(((dble(j+1)-x(i))+(dble(j+1)-x(i+1))) > 1.0d0) then\n",
      "                   call setbox(materialID, j,y1,i , x2-j+x1,y2,z2-i+z1)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setZX_Ycylinder\n",
      "  subroutine setXY_Zcylinder2(materialID, x1,y1,z1 , x2,y2,z2)\n",
      "    integer :: materialID\n",
      "    integer :: x1, y1, z1\n",
      "    integer :: x2, y2, z2\n",
      "    integer :: i, j\n",
      "    real*8 :: a, b, xc, yc\n",
      "    real*8 :: y(x1:x2), x(y1:y2)\n",
      "    a = dble(x2 - x1)*0.5d0*1.000001d0\n",
      "    b = dble(y2 - y1)*0.5d0*1.000001d0\n",
      "    xc = dble(x1 + x2)*0.5d0\n",
      "    yc = dble(y1 + y2)*0.5d0\n",
      "    do j=y1, y2\n",
      "       x(j) = -a*sqrt(1.0d0 - (dble(j-yc)**2)/dble(b**2)) +xc\n",
      "    enddo\n",
      "    do i=x1, x2\n",
      "       y(i) = -b*sqrt(1.0d0 - (dble(i-xc)**2)/dble(a**2)) +yc\n",
      "    enddo\n",
      "    do j=y1, int(yc - 0.01d0)\n",
      "       do i=x1, int(xc - 0.01d0)\n",
      "          if(x(j) < i)then\n",
      "             ! OK\n",
      "             call setbox2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "             exit\n",
      "          else if((i < x(j)) .and. (x(j) < i+1)) then\n",
      "             if((j < y(i)) .and. y(i) < j+1) then\n",
      "           ! OK\n",
      "                call setbox2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                exit\n",
      "             else\n",
      "                ! [/]type\n",
      "                if(((dble(i+1)-x(j))+(dble(i+1)-x(j+1))) > 1.0d0) then\n",
      "                   call setbox2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "           endif\n",
      "             endif\n",
      "          else\n",
      "             if(y(i) < j+1) then\n",
      "                ![/] type\n",
      "                if(((dble(j+1)-y(i))+(dble(j+1)-y(i+1))) > 1.0d0) then\n",
      "                   call setbox2(materialID, i,j,z1 , x2-i+x1,y2-j+y1,z2)\n",
      "                   exit\n",
      "                endif\n",
      "             endif\n",
      "          endif\n",
      "       enddo\n",
      "    enddo\n",
      "  end subroutine setXY_Zcylinder2\n",
      "  subroutine setsphere(materialID, xc, yc, zc, r)\n",
      "    integer :: materialID, xc,yc,zc, r\n",
      "    integer :: i\n",
      "    \n",
      "    call setbox(materialID, xc-r,yc-1,zc-1, xc+r,yc+1,zc+1)\n",
      "    call setbox(materialID, xc-1,yc-r,zc-1, xc+1,yc+r,zc+1)\n",
      "    call setbox(materialID, xc-1,yc-1,zc-r, xc+1,yc+1,zc+r)\n",
      "    \n",
      "    do i=2, r-1\n",
      "       call setXY_Zcylinder(materialID, &\n",
      "            & xc-i,yc-i,zc-nint(sqrt(dble(r*r - i*i))), &\n",
      "            & xc+i, yc+i, zc+nint(sqrt(dble(r*r - i*i))))\n",
      "    end do\n",
      "    do i=2, r-1\n",
      "       call setYZ_Xcylinder(materialID, &\n",
      "            & xc-nint(sqrt(dble(r*r - i*i))),yc-i,zc-i, &\n",
      "            & xc+nint(sqrt(dble(r*r - i*i))), yc+i, zc+i)\n",
      "    end do\n",
      "    do i=2, r-1\n",
      "       call setZX_Ycylinder(materialID, &\n",
      "            & xc-i,yc-nint(sqrt(dble(r*r - i*i))),zc-i, &\n",
      "            & xc+i, yc+nint(sqrt(dble(r*r - i*i))), zc+i)\n",
      "    end do\n",
      "  end subroutine setsphere\n",
      "  \n",
      "  subroutine SetMaterialAtFeedPoint\n",
      "    integer :: i,x,y,z, nfeed2\n",
      "    nfeed2 = 0\n",
      "    do i=1, nfeed\n",
      "       select case (feedAxis(i))\n",
      "       case('x')\n",
      "          if((nzS(id) <= feedz(i)) .and. (feedz(i) <= nzE(id))) then\n",
      "             do x=feedx(i), feedx(i)+(feedLength(i)-1)*feedSign(i), feedSign(i)\n",
      "                IDEx(x,feedy(i),feedz(i)) = -1\n",
      "             end do\n",
      "          end if\n",
      "          XC_pat = XC_pat + dble(feedx(i)) &\n",
      "               & + dble(feedSign(i)*(feedLength(i)-1))/2.0d0\n",
      "          YC_pat = YC_pat + dble(feedy(i))\n",
      "          ZC_pat = ZC_pat + dble(feedz(i))\n",
      "          nfeed2 = nfeed2 + 1\n",
      "       case('y')\n",
      "          if((nzS(id) <= feedz(i)) .and. (feedz(i) <= nzE(id))) then\n",
      "             do y=feedy(i), feedy(i)+(feedLength(i)-1)*feedSign(i), feedSign(i)\n",
      "                IDEy(feedx(i),y,feedz(i)) = -1\n",
      "             end do\n",
      "          end if\n",
      "          XC_pat = XC_pat + dble(feedx(i))\n",
      "          YC_pat = YC_pat + dble(feedy(i)) &\n",
      "               & + dble(feedSign(i)*(feedLength(i)-1))/2.0d0\n",
      "          ZC_pat = ZC_pat + dble(feedz(i))\n",
      "          nfeed2 = nfeed2 + 1\n",
      "       case('z')\n",
      "          do z=feedz(i), feedz(i)+(feedLength(i)-1)*feedSign(i), feedSign(i)\n",
      "             if((nzS(id) <= z) .and. (z <= nzE(id))) then\n",
      "                IDEz(feedx(i),feedy(i),z) = -1\n",
      "             end if\n",
      "          end do\n",
      "          XC_pat = XC_pat + dble(feedx(i))\n",
      "          YC_pat = YC_pat + dble(feedy(i))\n",
      "          ZC_pat = ZC_pat + dble(feedz(i)) &\n",
      "               & + dble(feedSign(i)*(feedLength(i)-1))/2.0d0\n",
      "          nfeed2 = nfeed2 + 1\n",
      "       end select\n",
      "    enddo\n",
      "    \n",
      "    XC_pat = XC_pat / dble(nfeed2)\n",
      "    YC_pat = YC_pat / dble(nfeed2)\n",
      "    ZC_pat = ZC_pat / dble(nfeed2)\n",
      "  end subroutine SetMaterialAtFeedPoint\n",
      "  \n",
      "  subroutine setCP_integer(materialID, x,y,z, lx1,ly1,lz1, lx2,ly2,lz2, S, flag)\n",
      "    integer :: materialID\n",
      "    integer :: x,y,z, flag\n",
      "    integer :: lx1,ly1,lz1, lx2,ly2,lz2, S\n",
      "    \n",
      "    call setCP_real(materialID, x,y,z, &\n",
      "         & dble(lx1)*0.01d0, dble(ly1)*0.01d0, dble(lz1)*0.01d0, &\n",
      "         & dble(lx2)*0.01d0, dble(ly2)*0.01d0, dble(lz2)*0.01d0, &\n",
      "         & dble(S)*0.01d0, flag)\n",
      "  end subroutine setCP_integer\n",
      "  subroutine setCP_real(materialID, x,y,z, lx1,ly1,lz1, lx2,ly2,lz2, S, flag)\n",
      "    integer :: materialID\n",
      "    integer :: x,y,z\n",
      "    real*8 :: lx1,ly1,lz1, lx2,ly2,lz2\n",
      "    real*8 :: S\n",
      "    integer :: flag\n",
      "    integer, dimension(:), allocatable :: tempCPX, tempCPY, tempCPZ\n",
      "    integer, dimension(:), allocatable :: tempCPplaneFlag\n",
      "    real*8, dimension(:), allocatable :: templlx1, templly1, templlz1\n",
      "    real*8, dimension(:), allocatable :: templlx2, templly2, templlz2\n",
      "    real*8, dimension(:), allocatable :: tempsq\n",
      "    \n",
      "    trush = dble(materialID)\n",
      "    cpPoint = cpPoint + 1\n",
      "    \n",
      "    if(CPFlag == 0) then\n",
      "       if(cpPoint == 1) then\n",
      "          write(*,*) 'WARNING : CPFlag is equal to 0.'\n",
      "       end if\n",
      "       return\n",
      "    end if\n",
      "    \n",
      "    if(cpPoint /= 1) then\n",
      "       allocate(tempCPX(cpPoint-1))\n",
      "       allocate(tempCPY(cpPoint-1))\n",
      "       allocate(tempCPZ(cpPoint-1))\n",
      "       allocate(tempCPplaneFlag(cpPoint-1));\n",
      "       allocate(templlx1(cpPoint-1)); allocate(templlx2(cpPoint-1))\n",
      "       allocate(templly1(cpPoint-1)); allocate(templly2(cpPoint-1))\n",
      "       allocate(templlz1(cpPoint-1)); allocate(templlz2(cpPoint-1))\n",
      "       allocate(tempsq(cpPoint-1))\n",
      "       tempCPX = cpX; tempCPY = cpY; tempCPZ = cpZ; tempCPplaneFlag = cpPlaneFlag\n",
      "       templlx1 = llx1; templly1 = lly1; templlz1 = llz1\n",
      "       templlx2 = llx2; templly2 = lly2; templlz2 = llz2\n",
      "       tempsq = sq\n",
      "       deallocate(cpX); deallocate(cpY); deallocate(cpZ)\n",
      "       deallocate(cpPlaneFlag)\n",
      "       deallocate(llx1); deallocate(lly1); deallocate(llz1)\n",
      "       deallocate(llx2); deallocate(lly2); deallocate(llz2)\n",
      "       deallocate(sq)\n",
      "    end if\n",
      "    allocate(cpX(cpPoint)); allocate(cpY(cpPoint)); allocate(cpZ(cpPoint))\n",
      "    allocate(cpPlaneFlag(cpPoint))\n",
      "    allocate(llx1(cpPoint)); allocate(lly1(cpPoint)); allocate(llz1(cpPoint))\n",
      "    allocate(llx2(cpPoint)); allocate(lly2(cpPoint)); allocate(llz2(cpPoint))\n",
      "    allocate(sq(cpPoint))\n",
      "    if(cpPoint /= 1) then\n",
      "       cpX(1:cpPoint-1) = tempCPX\n",
      "       cpY(1:cpPoint-1) = tempCPY\n",
      "       cpZ(1:cpPoint-1) = tempCPZ\n",
      "       cpPlaneFlag(1:cpPoint-1) = tempCPplaneFlag\n",
      "       llx1(1:cpPoint-1) = templlx1; llx2(1:cpPoint-1) = templlx2\n",
      "       lly1(1:cpPoint-1) = templly1; lly2(1:cpPoint-1) = templly2\n",
      "       llz1(1:cpPoint-1) = templlz1; llz2(1:cpPoint-1) = templlz2\n",
      "       sq(1:cpPoint-1) = tempsq\n",
      "       deallocate(tempCPX); deallocate(tempCPY); deallocate(tempCPZ)\n",
      "       deallocate(tempCPplaneFlag)\n",
      "       deallocate(templlx1); deallocate(templly1); deallocate(templlz1)\n",
      "       deallocate(templlx2); deallocate(templly2); deallocate(templlz2)\n",
      "       deallocate(tempsq)\n",
      "    end if\n",
      "    \n",
      "    cpX(cpPoint) = x; cpY(cpPoint) = y; cpZ(cpPoint) = z\n",
      "    cpPlaneFlag(cpPoint) = flag\n",
      "    llx1(cpPoint) = lx1; lly1(cpPoint) = ly1; llz1(cpPoint) = lz1\n",
      "    llx2(cpPoint) = lx2; lly2(cpPoint) = ly2; llz2(cpPoint) = lz2\n",
      "    sq(cpPoint) = S\n",
      "  end subroutine setCP_real\n",
      "  subroutine setMaterialAtCPcell\n",
      "    integer :: i, count\n",
      "    \n",
      "    if((CPFlag /= 1) .or. (cpPoint == 0)) then\n",
      "       return\n",
      "    end if\n",
      "    \n",
      "    do i=1, cpPoint\n",
      "       if(llx1(i) < DBL_EPSILON) then\n",
      "          call setline(1, cpX(i),cpY(i),cpZ(i), cpX(i)+1,cpY(i),cpZ(i))\n",
      "       end if\n",
      "       if(llx2(i) < DBL_EPSILON) then\n",
      "          select case (cpPlaneFlag(i))\n",
      "          case (2)\n",
      "             call setline(1, cpX(i),cpY(i),cpZ(i)+1, cpX(i)+1,cpY(i),cpZ(i)+1)\n",
      "          case (3)\n",
      "             call setline(1, cpX(i),cpY(i)+1,cpZ(i), cpX(i)+1,cpY(i)+1,cpZ(i))\n",
      "          end select\n",
      "       end if\n",
      "       if(lly1(i) < DBL_EPSILON) then\n",
      "          call setline(1, cpX(i),cpY(i),cpZ(i), cpX(i),cpY(i)+1,cpZ(i))\n",
      "       end if\n",
      "       if(lly2(i) < DBL_EPSILON) then\n",
      "          select case (cpPlaneFlag(i))\n",
      "          case (1)\n",
      "             call setline(1, cpX(i),cpY(i),cpZ(i)+1, cpX(i),cpY(i)+1,cpZ(i)+1)\n",
      "          case (3)\n",
      "             call setline(1, cpX(i)+1,cpY(i),cpZ(i), cpX(i)+1,cpY(i)+1,cpZ(i))\n",
      "          end select\n",
      "       end if\n",
      "       if(llz1(i) < DBL_EPSILON) then\n",
      "          call setline(1, cpX(i),cpY(i),cpZ(i), cpX(i),cpY(i),cpZ(i)+1)\n",
      "       end if\n",
      "       if(llz2(i) < DBL_EPSILON) then\n",
      "          select case (cpPlaneFlag(i))\n",
      "          case (1)\n",
      "             call setline(1, cpX(i),cpY(i)+1,cpZ(i), cpX(i),cpY(i)+1,cpZ(i)+1)\n",
      "          case (2)\n",
      "             call setline(1, cpX(i)+1,cpY(i),cpZ(i), cpX(i)+1,cpY(i),cpZ(i)+1)\n",
      "          end select\n",
      "       end if\n",
      "       count = 0\n",
      "       if(llx1(i) < DBL_EPSILON) then\n",
      "          count = count + 1\n",
      "       end if\n",
      "       if(llx2(i) < DBL_EPSILON) then\n",
      "          count = count + 1\n",
      "       end if\n",
      "       if(lly1(i) < DBL_EPSILON) then\n",
      "          count = count + 1\n",
      "       end if\n",
      "       if(lly2(i) < DBL_EPSILON) then\n",
      "          count = count + 1\n",
      "       end if\n",
      "       if(llz1(i) < DBL_EPSILON) then\n",
      "          count = count + 1\n",
      "       end if\n",
      "       if(llz2(i) < DBL_EPSILON) then\n",
      "          count = count + 1\n",
      "       end if\n",
      "       if(count >= 3) then\n",
      "          select case(cpPlaneFlag(i))\n",
      "          case (1)\n",
      "             call setplane(1, cpX(i),cpY(i),cpZ(i), cpX(i),cpY(i)+1,cpZ(i)+1)\n",
      "          case (2)\n",
      "             call setplane(1, cpX(i),cpY(i),cpZ(i), cpX(i)+1,cpY(i),cpZ(i)+1)\n",
      "          case (3)\n",
      "             call setplane(1, cpX(i),cpY(i),cpZ(i), cpX(i)+1,cpY(i)+1,cpZ(i))\n",
      "          end select\n",
      "          cpPlaneFlag(i) = -1\n",
      "       end if\n",
      "       if(sq(i) < 0.25d0) then\n",
      "          select case(cpPlaneFlag(i))\n",
      "             case (1)\n",
      "                call setplane(1, cpX(i),cpY(i),cpZ(i), cpX(i),cpY(i)+1,cpZ(i)+1)\n",
      "             case (2)\n",
      "                call setplane(1, cpX(i),cpY(i),cpZ(i), cpX(i)+1,cpY(i),cpZ(i)+1)\n",
      "             case (3)\n",
      "                call setplane(1, cpX(i),cpY(i),cpZ(i), cpX(i)+1,cpY(i)+1,cpZ(i))\n",
      "          end select\n",
      "          cpPlaneFlag(i) = -1\n",
      "       end if\n",
      "    end do\n",
      "    call sortCPcell\n",
      "    call mountCPcell\n",
      "    call realizeCPparameter\n",
      "  end subroutine setMaterialAtCPcell\n",
      "  subroutine sortCPcell\n",
      "    integer i, j, min_j, min_z, itemp\n",
      "    real*8 :: rtemp\n",
      "    \n",
      "    if(cpPoint == 1) then\n",
      "       if(cpPlaneFlag(1) == -1) then\n",
      "          cpPoint = 0\n",
      "       end if\n",
      "       return\n",
      "    end if\n",
      "    ! Selection sort\n",
      "    do i=1, cpPoint-1\n",
      "       ! Set default value.\n",
      "       min_j = i\n",
      "       if(cpPlaneFlag(i) == -1) then\n",
      "          min_z = (nz+1)*(ny+1)*(nx+1)\n",
      "       else\n",
      "          min_z = cpZ(i)*(nx+1)*(ny+1) + cpY(i)*(nx+1) + cpX(i)\n",
      "       end if\n",
      "       ! Find minimum value.\n",
      "       do j=i+1, cpPoint\n",
      "          if(cpPlaneFlag(j) /= -1) then\n",
      "             if(cpZ(j)*(nx+1)*(ny+1) + cpY(j)*(nx+1) + cpX(j) < min_z) then\n",
      "                min_j = j\n",
      "                min_z = cpZ(j)*(nx+1)*(ny+1) + cpY(j)*(nx+1) + cpX(j)\n",
      "             end if\n",
      "          end if\n",
      "       end do\n",
      "       ! Swap.\n",
      "       if(min_j /= i) then\n",
      "          itemp = cpX(i); cpX(i) = cpX(min_j); cpX(min_j) = itemp\n",
      "          itemp = cpY(i); cpY(i) = cpY(min_j); cpY(min_j) = itemp\n",
      "          itemp = cpZ(i); cpZ(i) = cpZ(min_j); cpZ(min_j) = itemp\n",
      "          itemp = cpPlaneFlag(i)\n",
      "          cpPlaneFlag(i) = cpPlaneFlag(min_j)\n",
      "          cpPlaneFlag(min_j) = itemp\n",
      "          rtemp = llx1(i); llx1(i) = llx1(min_j); llx1(min_j) = rtemp\n",
      "          rtemp = lly1(i); lly1(i) = lly1(min_j); lly1(min_j) = rtemp\n",
      "          rtemp = llz1(i); llz1(i) = llz1(min_j); llz1(min_j) = rtemp\n",
      "          rtemp = llx2(i); llx2(i) = llx2(min_j); llx2(min_j) = rtemp\n",
      "          rtemp = lly2(i); lly2(i) = lly2(min_j); lly2(min_j) = rtemp\n",
      "          rtemp = llz2(i); llz2(i) = llz2(min_j); llz2(min_j) = rtemp\n",
      "          rtemp = sq(i); sq(i) = sq(min_j); sq(min_j) = rtemp\n",
      "       end if\n",
      "       ! Finish sorting.\n",
      "       if(min_z == (nz+1)*(ny+1)*(nx+1)) then\n",
      "          cpPoint = i - 1\n",
      "          exit\n",
      "       end if\n",
      "    end do\n",
      "    ! If Only one CP cell exists.\n",
      "    if(cpPlaneFlag(cpPoint) == -1) then\n",
      "       cpPoint = cpPoint - 1\n",
      "    end if\n",
      "  end subroutine sortCPcell\n",
      "  subroutine mountCPcell\n",
      "    integer :: z, i, next_i\n",
      "    \n",
      "    cpS = -1\n",
      "    cpE = -1\n",
      "    \n",
      "    if(cpPoint == 0) then\n",
      "       return\n",
      "    end if\n",
      "    \n",
      "    next_i = 1\n",
      "    do z=1, nz\n",
      "       if(next_i == cpPoint+1) then\n",
      "          cycle\n",
      "       end if\n",
      "       do i=next_i, cpPoint\n",
      "          if(cpZ(i) > z) then\n",
      "             exit\n",
      "          else if(cpZ(i) == z) then\n",
      "             if(cpS(z) == -1) then\n",
      "                cpS(z) = i\n",
      "             end if\n",
      "             cpE(z) = i\n",
      "             next_i = i+1\n",
      "             cycle\n",
      "          else\n",
      "             stop 'Program Error. (mountCPcell)'\n",
      "          end if\n",
      "       end do\n",
      "    end do\n",
      "  end subroutine mountCPcell\n",
      "  subroutine realizeCPparameter\n",
      "    integer :: i\n",
      "    \n",
      "    if(cpPoint == 0) then\n",
      "       return\n",
      "    end if\n",
      "    allocate(CHCP(cpPoint))\n",
      "    llx1 = llx1*dx; lly1 = lly1*dy; llz1 = llz1*dz\n",
      "    llx2 = llx2*dx; lly2 = lly2*dy; llz2 = llz2*dz\n",
      "    do i=1, cpPoint\n",
      "       select case (cpPlaneFlag(i))\n",
      "          case (1)\n",
      "             sq(i) = sq(i)*dy*dz\n",
      "             CHCP(i) = dt/mu0/sq(i)\n",
      "          case (2)\n",
      "             sq(i) = sq(i)*dz*dx\n",
      "             CHCP(i) = dt/mu0/sq(i)\n",
      "          case (3)\n",
      "             sq(i) = sq(i)*dx*dy\n",
      "             CHCP(i) = dt/mu0/sq(i)\n",
      "       end select\n",
      "    end do\n",
      "  end subroutine realizeCPparameter\n",
      "end module setup\n",
      "module fdtd\n",
      "  use setup\n",
      "  implicit none\n",
      "contains\n",
      "  subroutine initialize\n",
      "    real*8 :: Sglmax\n",
      "    real*8 :: SglA(1:LM), SglB(1:LM)\n",
      "    integer :: cost(1:nz), totalcost, idealcost\n",
      "    integer, dimension(:), allocatable :: localcost\n",
      "    integer :: surplusL, mincost, mincostP\n",
      "    integer :: idS, idE, pmlS, pmlE, pmlE1, pmlS2\n",
      "    integer :: i, k, p\n",
      "    dt = CFL/(c*(((1.0d0/dx)**2)+((1.0d0/dy)**2)+((1.0d0/dz)**2))**0.5d0)\n",
      "    df = 1.0d0/dt/nt\n",
      "    call MPI_init(error_code)\n",
      "    call MPI_comm_size(MPI_COMM_WORLD, np, error_code)\n",
      "    call MPI_comm_rank(MPI_COMM_WORLD, id, error_code)\n",
      "    call MPI_type_contiguous(nx*ny, MPI_DOUBLE_PRECISION, MatrixXY, error_code)\n",
      "    call MPI_type_commit(MatrixXY, error_code)\n",
      "    zm = id - 1\n",
      "    zp = id + 1\n",
      "    if(id == 0) then\n",
      "       zm = MPI_PROC_NULL\n",
      "    endif\n",
      "    if(id == np-1) then\n",
      "       zp = MPI_PROC_NULL\n",
      "    endif\n",
      "    ! PML cost\n",
      "    do k=1, nz\n",
      "       cost(k) = 24*nx*ny\n",
      "    enddo\n",
      "    ! EH cost\n",
      "    do k=LM+1, nz-LM\n",
      "       cost(k) = cost(k) - 9*(nx-2*LM)*(ny-2*LM)\n",
      "    enddo\n",
      "    ! Pattern cost\n",
      "    if((patternFlag /= 0) .or. (efficiencyFlag /= 0)) then\n",
      "       cost(ZS_pat) = cost(ZS_pat) &\n",
      "            & + 4*freqPoint_pat*(XE_pat-XS_pat+1)*(YE_pat-YS_pat+1)\n",
      "       cost(ZE_pat+1) = cost(ZE_pat+1) &\n",
      "            & + 4*freqPoint_pat*(XE_pat-XS_pat+1)*(YE_pat-YS_pat+1)\n",
      "       cost(ZS_pat:ZE_pat) = cost(ZS_pat:ZE_pat) &\n",
      "            & + 4*freqPoint_pat*(XE_pat-XS_pat+1)*2 &\n",
      "            & + 4*freqPoint_pat*(YE_pat-YS_pat+1)*2\n",
      "    end if\n",
      "    ! PLRC cost\n",
      "    if(PLRCFlag /= 0) then\n",
      "       do k=ZS_RC, ZE_RC\n",
      "          cost(k) = cost(k) + 4*(XE_RC-XS_RC+1)*(YE_RC-YS_RC+1)\n",
      "       end do\n",
      "    end if\n",
      "    ! CP cost\n",
      "    if((CPFlag /= 0) .and. (cpPoint > 0)) then\n",
      "       do i=1, cpPoint\n",
      "          cost(cpZ(i)) = cost(cpZ(i)) + 7\n",
      "       end do\n",
      "    end if\n",
      "    ! Current distribution cost\n",
      "    if(CDFlag /= 0) then\n",
      "       if((ZS_CD == ZE_CD) .and. (XS_CD /= XE_CD) .and. (YS_CD /= YE_CD)) then\n",
      "          cost(ZS_CD) = cost(ZS_CD) + 4*freqPoint_CD*(XE_CD-XS_CD)*(YE_CD-YS_CD)\n",
      "       else\n",
      "          do k=ZS_CD, ZE_CD\n",
      "             cost(k) = cost(k) + 4*freqPoint_CD*(XE_CD-XS_CD) &\n",
      "                  & + 4*freqPoint_CD*(YE_CD-YS_CD)\n",
      "          end do\n",
      "       end if\n",
      "    end if\n",
      "    ! Electric field distribution cost\n",
      "    if(EDFlag /= 0) then\n",
      "       if(ZS_ED == ZE_ED) then\n",
      "          cost(ZS_ED) = cost(ZS_ED) + 4*freqPoint_ED*(XE_ED-XS_ED)*(YE_ED-YS_ED)\n",
      "       else\n",
      "          do k=ZS_ED, ZE_ED\n",
      "             cost(k) = cost(k) + 4*freqPoint_ED*(XE_ED-XS_ED) &\n",
      "                  & + 4*freqPoint_ED*(YE_ED-YS_ED)\n",
      "          end do\n",
      "       end if\n",
      "    end if\n",
      "    totalcost = sum(cost)\n",
      "    idealcost = totalcost / np\n",
      "    \n",
      "    allocate(nzS(0:np))\n",
      "    allocate(nzE(-1:np-1))\n",
      "    allocate(nzL(0:np-1))\n",
      "    allocate(localcost(0:np-1))\n",
      "    nzE(-1) = 0\n",
      "    nzS(np) = nz+1\n",
      "    do p=0, int((np-1)/2)\n",
      "       nzS(p) = nzE(p-1)+1\n",
      "       nzE(p) = nzS(np-p)-1\n",
      "       localcost(p) = 0\n",
      "       do k=nzS(p), nzS(np-p)\n",
      "          localcost(p) = localcost(p) + cost(k)\n",
      "          if(localcost(p) > idealcost) then\n",
      "             if((localcost(p)-idealcost) < (idealcost-localcost(p)+cost(k))) then\n",
      "                nzE(p) = k\n",
      "             else\n",
      "                nzE(p) = k-1\n",
      "                localcost(p) = localcost(p) - cost(k)\n",
      "             endif\n",
      "             exit\n",
      "          endif\n",
      "       enddo\n",
      "       nzL(p) = nzE(p) - nzS(p) + 1\n",
      "       nzS(np-p-1) = nzE(p)+1\n",
      "       nzE(np-p-1) = nzS(np-p)-1\n",
      "       localcost(np-p-1) = 0\n",
      "       do k=nzE(np-p-1), nzE(p)+1, -1\n",
      "          localcost(np-p-1) = localcost(np-p-1) + cost(k)\n",
      "          if(localcost(np-p-1) > idealcost) then\n",
      "             if((localcost(np-p-1)-idealcost) & \n",
      "                  & < (idealcost-localcost(np-p-1)+cost(k))) then\n",
      "                nzS(np-p-1) = k\n",
      "             else\n",
      "                nzS(np-p-1) = k+1\n",
      "                localcost(np-p-1) = localcost(np-p-1) - cost(k)\n",
      "             endif\n",
      "             exit\n",
      "          endif\n",
      "       enddo\n",
      "       nzL(np-p-1) = nzE(np-p-1) - nzS(np-p-1) + 1\n",
      "    enddo\n",
      "    surplusL = nz\n",
      "    do p=0, np-1\n",
      "       surplusL = surplusL - nzL(p)\n",
      "    enddo\n",
      "    if(surplusL > 0) then\n",
      "       do i=1, surplusL\n",
      "          mincost = localcost(0)\n",
      "          mincostP = 0\n",
      "          do p=0, np-1\n",
      "             if(localcost(p) < mincost) then\n",
      "                mincost = localcost(p)\n",
      "                mincostP = p\n",
      "             endif\n",
      "          enddo\n",
      "          if(mincostP <= int(np/2)-1) then\n",
      "             nzS(mincostP) = nzS(mincostP) - 1\n",
      "             nzL(mincostP) = nzL(mincostP) + 1\n",
      "             do p=mincostP, int(np/2)-1\n",
      "                nzS(p) = nzS(p)+1\n",
      "                nzE(p) = nzE(p)+1\n",
      "                localcost(p) = 0\n",
      "                do k=nzS(p), nzE(p)\n",
      "                   localcost(p) = localcost(p) + cost(k)\n",
      "                enddo\n",
      "             enddo\n",
      "          else\n",
      "             nzE(mincostP) = nzE(mincostP) + 1\n",
      "             nzL(mincostP) = nzL(mincostP) + 1\n",
      "             do p=mincostP, int(np/2), -1\n",
      "                nzE(p) = nzE(p) - 1\n",
      "                nzS(p) = nzS(p) - 1\n",
      "                localcost(p) = 0\n",
      "                do k=nzS(p), nzE(p)\n",
      "                   localcost(p) = localcost(p) + cost(k)\n",
      "                enddo\n",
      "             enddo\n",
      "          endif\n",
      "       enddo\n",
      "    endif\n",
      "    deallocate(localcost)\n",
      "    allocate(Ex(1:nx, 1:ny, nzS(id):nzE(id)+1))\n",
      "    allocate(Ey(1:nx, 1:ny, nzS(id):nzE(id)+1))\n",
      "    allocate(Ez(1:nx, 1:ny, nzS(id):nzE(id)))\n",
      "    allocate(Hx(1:nx, 1:ny, nzS(id)-1:nzE(id)))\n",
      "    allocate(Hy(1:nx, 1:ny, nzS(id)-1:nzE(id)))\n",
      "    allocate(Hz(1:nx, 1:ny, nzS(id):nzE(id)))\n",
      "    Ex = 0.0d0; Ey = 0.0d0; Ez = 0.0d0\n",
      "    Hx = 0.0d0; Hy = 0.0d0; Hz = 0.0d0\n",
      "    if(LM < nzS(id)) then\n",
      "       idS = nzS(id)\n",
      "    else\n",
      "       idS = LM+1\n",
      "    endif\n",
      "    if(nzE(id) < nz-LM+1) then\n",
      "       idE = nzE(id)\n",
      "    else\n",
      "       idE = nz-LM\n",
      "    endif\n",
      "    if(idS <= idE) then\n",
      "       allocate(IDEx(LM+1:nx-LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(IDEy(LM+1:nx-LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(IDEz(LM+1:nx-LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(IDHx(LM+1:nx-LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(IDHy(LM+1:nx-LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(IDHz(LM+1:nx-LM, LM+1:ny-LM, idS:idE))\n",
      "       IDEx = 0; IDEy = 0; IDEz = 0\n",
      "       IDHx = 0; IDHy = 0; IDHz = 0\n",
      "    endif\n",
      "    if(nzS(id) <= LM) then\n",
      "       pmlS = nzS(id)\n",
      "    else if(nz-LM+1 <= nzS(id)) then\n",
      "       pmlS = nzS(id)\n",
      "    else\n",
      "       pmlS = nz-LM+1\n",
      "    endif\n",
      "    if(nzE(id) >= nz-LM+1) then\n",
      "       pmlE = nzE(id)\n",
      "    else if(LM >= nzE(id)) then\n",
      "       pmlE = nzE(id)\n",
      "    else\n",
      "       pmlE = LM\n",
      "    endif\n",
      "    if(pmlS <= LM) then\n",
      "       if(pmlE < nz-LM) then\n",
      "          pmlE1 = pmlE\n",
      "       else\n",
      "          pmlE1 = LM\n",
      "       endif\n",
      "       allocate(Exy1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Exz1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Eyz1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Eyx1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Ezx1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Ezy1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Hxy1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Hxz1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Hyz1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Hyx1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Hzx1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       allocate(Hzy1(1:nx, 1:ny, pmlS:pmlE1))\n",
      "       Exy1 = 0.0d0; Exz1 = 0.0d0; Hxy1 = 0.0d0; Hxz1 = 0.0d0\n",
      "       Eyz1 = 0.0d0; Eyx1 = 0.0d0; Hyz1 = 0.0d0; Hyx1 = 0.0d0\n",
      "       Ezx1 = 0.0d0; Ezy1 = 0.0d0; Hzx1 = 0.0d0; Hzy1 = 0.0d0\n",
      "    endif\n",
      "    if(pmlE >= nz-LM+1) then\n",
      "       if(pmlS > LM) then\n",
      "          pmlS2 = pmlS\n",
      "       else\n",
      "          pmlS2 = nz-LM+1\n",
      "       endif\n",
      "       allocate(Exy2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Exz2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Eyz2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Eyx2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Ezx2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Ezy2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Hxy2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Hxz2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Hyz2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Hyx2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Hzx2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       allocate(Hzy2(1:nx, 1:ny, pmlS2:pmlE))\n",
      "       Exy2 = 0.0d0; Exz2 = 0.0d0; Hxy2 = 0.0d0; Hxz2 = 0.0d0\n",
      "       Eyz2 = 0.0d0; Eyx2 = 0.0d0; Hyz2 = 0.0d0; Hyx2 = 0.0d0\n",
      "       Ezx2 = 0.0d0; Ezy2 = 0.0d0; Hzx2 = 0.0d0; Hzy2 = 0.0d0\n",
      "    endif\n",
      "    if(idE >= idS) then\n",
      "       allocate(Exy3(1:nx, 1:LM, idS:idE)); allocate(Exz3(1:nx, 1:LM, idS:idE))\n",
      "       allocate(Eyz3(1:nx, 1:LM, idS:idE)); allocate(Eyx3(1:nx, 1:LM, idS:idE))\n",
      "       allocate(Ezx3(1:nx, 1:LM, idS:idE)); allocate(Ezy3(1:nx, 1:LM, idS:idE))\n",
      "       allocate(Hxy3(1:nx, 1:LM, idS:idE)); allocate(Hxz3(1:nx, 1:LM, idS:idE))\n",
      "       allocate(Hyz3(1:nx, 1:LM, idS:idE)); allocate(Hyx3(1:nx, 1:LM, idS:idE))\n",
      "       allocate(Hzx3(1:nx, 1:LM, idS:idE)); allocate(Hzy3(1:nx, 1:LM, idS:idE))\n",
      "       Exy3 = 0.0d0; Exz3 = 0.0d0; Hxy3 = 0.0d0; Hxz3 = 0.0d0\n",
      "       Eyz3 = 0.0d0; Eyx3 = 0.0d0; Hyz3 = 0.0d0; Hyx3 = 0.0d0\n",
      "       Ezx3 = 0.0d0; Ezy3 = 0.0d0; Hzx3 = 0.0d0; Hzy3 = 0.0d0\n",
      "       allocate(Exy4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Exz4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Eyz4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Eyx4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Ezx4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Ezy4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Hxy4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Hxz4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Hyz4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Hyx4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Hzx4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       allocate(Hzy4(1:nx, ny-LM+1:ny, idS:idE))\n",
      "       Exy4 = 0.0d0; Exz4 = 0.0d0; Hxy4 = 0.0d0; Hxz4 = 0.0d0 \n",
      "       Eyz4 = 0.0d0; Eyx4 = 0.0d0; Hyz4 = 0.0d0; Hyx4 = 0.0d0 \n",
      "       Ezx4 = 0.0d0; Ezy4 = 0.0d0; Hzx4 = 0.0d0; Hzy4 = 0.0d0\n",
      "       allocate(Exy5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Exz5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Eyz5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Eyx5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Ezx5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Ezy5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hxy5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hxz5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hyz5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hyx5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hzx5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hzy5(1:LM, LM+1:ny-LM, idS:idE))\n",
      "       Exy5 = 0.0d0; Exz5 = 0.0d0; Hxy5 = 0.0d0; Hxz5 = 0.0d0\n",
      "       Eyz5 = 0.0d0; Eyx5 = 0.0d0; Hyz5 = 0.0d0; Hyx5 = 0.0d0\n",
      "       Ezx5 = 0.0d0; Ezy5 = 0.0d0; Hzx5 = 0.0d0; Hzy5 = 0.0d0\n",
      "       allocate(Exy6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Exz6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Eyz6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Eyx6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Ezx6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Ezy6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hxy6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hxz6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hyz6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hyx6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hzx6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       allocate(Hzy6(nx-LM+1:nx, LM+1:ny-LM, idS:idE))\n",
      "       Exy6 = 0.0d0; Exz6 = 0.0d0; Hxy6 = 0.0d0; Hxz6 = 0.0d0\n",
      "       Eyz6 = 0.0d0; Eyx6 = 0.0d0; Hyz6 = 0.0d0; Hyx6 = 0.0d0\n",
      "       Ezx6 = 0.0d0; Ezy6 = 0.0d0; Hzx6 = 0.0d0; Hzy6 = 0.0d0\n",
      "    endif\n",
      "    Sglmax = -dble(MM+1)*eps0*c/(2.0d0*dble(LM)*dx)*log(10.0d0**(RC0/20.0d0))\n",
      "    do i=1, LM\n",
      "       SglA(i) = Sglmax*(((dble(LM-i)+1.0d0)/dble(LM))**MM)\n",
      "       SglB(i) = Sglmax*(((dble(LM-i)+0.5d0)/dble(LM))**MM)\n",
      "    enddo\n",
      "    do i=1, LM\n",
      "       CpmlEdx(i) = (1.0d0-SglA(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))\n",
      "       CpmlEdxL(i) = (dt/eps0) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))/dx\n",
      "       CpmlHdx(i) = (1.0d0-SglB(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))\n",
      "       CpmlHdxL(i) = (dt/mu0) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))/dx\n",
      "       CpmlEdx(nx-i+1) = (1.0d0-SglB(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))\n",
      "       CpmlEdxL(nx-i+1) = (dt/eps0) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))/dx\n",
      "       CpmlHdx(nx-i+1) = (1.0d0-SglA(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))\n",
      "       CpmlHdxL(nx-i+1) = (dt/mu0) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))/dx\n",
      "    enddo\n",
      "    do i=LM+1, nx-LM\n",
      "       CpmlEdx(i) = 1.0d0\n",
      "       CpmlEdxL(i) = dt/eps0/dx\n",
      "       CpmlHdx(i) = 1.0d0\n",
      "       CpmlHdxL(i) = dt/mu0/dx\n",
      "    enddo\n",
      "    Sglmax = -dble(MM+1)*eps0*c/(2.0d0*dble(LM)*dy)*log(10.0d0**(RC0/20.0d0))\n",
      "    do i=1, LM\n",
      "       SglA(i) = Sglmax*(((dble(LM-i)+1.0d0)/dble(LM))**MM)\n",
      "       SglB(i) = Sglmax*(((dble(LM-i)+0.5d0)/dble(LM))**MM)\n",
      "    enddo\n",
      "    do i=1, LM\n",
      "       CpmlEdy(i) = (1.0d0-SglA(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))\n",
      "       CpmlEdyL(i) = (dt/eps0) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))/dy\n",
      "       CpmlHdy(i) = (1.0d0-SglB(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))\n",
      "       CpmlHdyL(i) = (dt/mu0) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))/dy\n",
      "       CpmlEdy(ny-i+1) = (1.0d0-SglB(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))\n",
      "       CpmlEdyL(ny-i+1) = (dt/eps0) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))/dy\n",
      "       CpmlHdy(ny-i+1) = (1.0d0-SglA(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))\n",
      "       CpmlHdyL(ny-i+1) = (dt/mu0) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))/dy\n",
      "    enddo\n",
      "    do i=LM+1, ny-LM\n",
      "       CpmlEdy(i) = 1.0d0\n",
      "       CpmlEdyL(i) = dt/eps0/dy\n",
      "       CpmlHdy(i) = 1.0d0\n",
      "       CpmlHdyL(i) = dt/mu0/dy\n",
      "    enddo\n",
      "    Sglmax = -dble(MM+1)*eps0*c/(2.0d0*dble(LM)*dz)*log(10.0d0**(RC0/20.0d0))\n",
      "    do i=1, LM\n",
      "       SglA(i) = Sglmax*(((dble(LM-i)+1.0d0)/dble(LM))**MM)\n",
      "       SglB(i) = Sglmax*(((dble(LM-i)+0.5d0)/dble(LM))**MM)\n",
      "    enddo\n",
      "    do i=1, LM\n",
      "       CpmlEdz(i) = (1.0d0-SglA(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))\n",
      "       CpmlEdzL(i) = (dt/eps0) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))/dz\n",
      "       CpmlHdz(i) = (1.0d0-SglB(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))\n",
      "       CpmlHdzL(i) = (dt/mu0) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))/dz\n",
      "       CpmlEdz(nz-i+1) = (1.0d0-SglB(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))\n",
      "       CpmlEdzL(nz-i+1) = (dt/eps0) &\n",
      "            & / (1.0d0+SglB(i)*dt/(2.0d0*eps0))/dz\n",
      "       CpmlHdz(nz-i+1) = (1.0d0-SglA(i)*dt/(2.0d0*eps0)) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))\n",
      "       CpmlHdzL(nz-i+1) = (dt/mu0) &\n",
      "            & / (1.0d0+SglA(i)*dt/(2.0d0*eps0))/dz\n",
      "    enddo\n",
      "    do i=LM+1, nz-LM\n",
      "       CpmlEdz(i) = 1.0d0\n",
      "       CpmlEdzL(i) = dt/eps0/dz\n",
      "       CpmlHdz(i) = 1.0d0\n",
      "       CpmlHdzL(i) = dt/mu0/dz\n",
      "    enddo\n",
      "    ! Special material\n",
      "    ! 0 : void\n",
      "    ! 1 : PEC\n",
      "    ! -1 : don't update E-field\n",
      "    CEx = (1.0d0-sgm0*dt/2.0d0/eps0)/(1.0d0+sgm0*dt/2.0d0/eps0)\n",
      "    CExLy = dt/eps0/(1.0d0+sgm0*dt/2.0d0/eps0)/dy\n",
      "    CExLz = dt/eps0/(1.0d0+sgm0*dt/2.0d0/eps0)/dz\n",
      "    CEy = (1.0d0-sgm0*dt/2.0d0/eps0)/(1.0d0+sgm0*dt/2.0d0/eps0)\n",
      "    CEyLz = dt/eps0/(1.0d0+sgm0*dt/2.0d0/eps0)/dz\n",
      "    CEyLx = dt/eps0/(1.0d0+sgm0*dt/2.0d0/eps0)/dx\n",
      "    CEz = (1.0d0-sgm0*dt/2.0d0/eps0)/(1.0d0+sgm0*dt/2.0d0/eps0)\n",
      "    CEzLx = dt/eps0/(1.0d0+sgm0*dt/2.0d0/eps0)/dx\n",
      "    CEzLy = dt/eps0/(1.0d0+sgm0*dt/2.0d0/eps0)/dy\n",
      "    CHxLy = dt/mu0/dy;    CHxLz = dt/mu0/dz\n",
      "    CHyLz = dt/mu0/dz;    CHyLx = dt/mu0/dx\n",
      "    CHzLx = dt/mu0/dx;    CHzLy = dt/mu0/dy\n",
      "    CPhi = 0.0d0; CPhi1 = 0.0d0; CPhi2 = 0.0d0; CPhi3 = 0.0d0\n",
      "    \n",
      "    CEx(1) = 0.0d0;    CExLy(1) = 0.0d0;    CExLz(1) = 0.0d0\n",
      "    CEy(1) = 0.0d0;    CEyLz(1) = 0.0d0;    CEyLx(1) = 0.0d0\n",
      "    CEz(1) = 0.0d0;    CEzLx(1) = 0.0d0;    CEzLy(1) = 0.0d0\n",
      "    CHxLy(1) = 0.0d0;  CHxLz(1) = 0.0d0\n",
      "    CHyLz(1) = 0.0d0;  CHyLx(1) = 0.0d0\n",
      "    CHzLx(1) = 0.0d0;  CHzLy(1) = 0.0d0\n",
      "    \n",
      "    CEx(-1) = 1.0d0;   CExLy(-1) = 0.0d0;   CExLz(-1) = 0.0d0\n",
      "    CEy(-1) = 1.0d0;   CEyLz(-1) = 0.0d0;   CEyLx(-1) = 0.0d0\n",
      "    CEz(-1) = 1.0d0;   CEzLx(-1) = 0.0d0;   CEzLy(-1) = 0.0d0\n",
      "    CHxLy(-1) = 0.0d0;  CHxLz(-1) = 0.0d0\n",
      "    CHyLz(-1) = 0.0d0;  CHyLx(-1) = 0.0d0\n",
      "    CHzLx(-1) = 0.0d0;  CHzLy(-1) = 0.0d0\n",
      "    \n",
      "    It = 0.0d0;  Vt = 0.0d0\n",
      "    If_imp = dcmplx(0.0d0, 0.0d0);  Vf_imp = dcmplx(0.0d0, 0.0d0)\n",
      "    If_pat = dcmplx(0.0d0, 0.0d0);  Vf_pat = dcmplx(0.0d0, 0.0d0)\n",
      "    if((patternFlag /= 0) .or. (efficiencyFlag /= 0)) then\n",
      "       ZSL_pat = nzS(id)\n",
      "       ZEL_pat = nzE(id)\n",
      "       if(nzS(id) <= ZS_pat) then\n",
      "          ZSL_pat = ZS_pat\n",
      "       end if\n",
      "       if(ZE_pat <= nzE(id)) then\n",
      "          ZEL_pat = ZE_pat\n",
      "       end if\n",
      "       if(ZSL_pat <= ZEL_pat) then\n",
      "          allocate(Ey1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Ez1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hy1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hz1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Ey2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Ez2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hy2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hz2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Ez3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Ex3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hz3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hx3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Ez4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Ex4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hz4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          allocate(Hx4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,1:freqPoint_pat))\n",
      "          Ey1 = dcmplx(0.0d0,0.0d0);  Ez1 = dcmplx(0.0d0,0.0d0)\n",
      "          Hy1 = dcmplx(0.0d0,0.0d0);  Hz1 = dcmplx(0.0d0,0.0d0)\n",
      "          Ey2 = dcmplx(0.0d0,0.0d0);  Ez2 = dcmplx(0.0d0,0.0d0)\n",
      "          Hy2 = dcmplx(0.0d0,0.0d0);  Hz2 = dcmplx(0.0d0,0.0d0)\n",
      "          Ez3 = dcmplx(0.0d0,0.0d0);  Ex3 = dcmplx(0.0d0,0.0d0)\n",
      "          Hz3 = dcmplx(0.0d0,0.0d0);  Hx3 = dcmplx(0.0d0,0.0d0)\n",
      "          Ez4 = dcmplx(0.0d0,0.0d0);  Ex4 = dcmplx(0.0d0,0.0d0)\n",
      "          Hz4 = dcmplx(0.0d0,0.0d0);  Hx4 = dcmplx(0.0d0,0.0d0)\n",
      "       end if\n",
      "       if(nzS(id) <= ZS_pat .and. ZS_pat <= nzE(id)) then\n",
      "          allocate(Ex5(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          allocate(Ey5(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          allocate(Hx5(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          allocate(Hy5(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          Ex5 = dcmplx(0.0d0,0.0d0);  Ey5 = dcmplx(0.0d0,0.0d0)\n",
      "          Hx5 = dcmplx(0.0d0,0.0d0);  Hy5 = dcmplx(0.0d0,0.0d0)\n",
      "       end if\n",
      "       if(nzS(id) <= ZE_pat+1 .and. ZE_pat+1 <= nzE(id)) then\n",
      "          allocate(Ex6(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          allocate(Ey6(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          allocate(Hx6(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          allocate(Hy6(XS_pat:XE_pat,YS_pat:YE_pat,1:freqPoint_pat))\n",
      "          Ex6 = dcmplx(0.0d0,0.0d0);  Ey6 = dcmplx(0.0d0,0.0d0)\n",
      "          Hx6 = dcmplx(0.0d0,0.0d0);  Hy6 = dcmplx(0.0d0,0.0d0)\n",
      "       end if\n",
      "    end if\n",
      "    if(PLRCFlag /= 0) then\n",
      "       ZSL_RC = nzS(id)\n",
      "       ZEL_RC = nzE(id)\n",
      "       if(nzS(id) <= ZS_RC) then\n",
      "          ZSL_RC = ZS_RC\n",
      "       end if\n",
      "       if(ZE_RC <= nzE(id)) then\n",
      "          ZEL_RC = ZE_RC\n",
      "       end if\n",
      "       if(ZSL_RC <= ZEL_RC) then\n",
      "          allocate(ExSaveRC(XS_RC:XE_RC, YS_RC:YE_RC, ZSL_RC:ZEL_RC))\n",
      "          allocate(EySaveRC(XS_RC:XE_RC, YS_RC:YE_RC, ZSL_RC:ZEL_RC))\n",
      "          allocate(EzSaveRC(XS_RC:XE_RC, YS_RC:YE_RC, ZSL_RC:ZEL_RC))\n",
      "          allocate(PHIx(XS_RC:XE_RC, YS_RC:YE_RC, ZSL_RC:ZEL_RC))\n",
      "          allocate(PHIy(XS_RC:XE_RC, YS_RC:YE_RC, ZSL_RC:ZEL_RC))\n",
      "          allocate(PHIz(XS_RC:XE_RC, YS_RC:YE_RC, ZSL_RC:ZEL_RC))\n",
      "          ExSaveRC = 0.0d0; EySaveRC = 0.0d0; EzSaveRC = 0.0d0\n",
      "          PHIx = 0.0d0; PHIy = 0.0d0; PHIz = 0.0d0\n",
      "       end if\n",
      "    end if\n",
      "    \n",
      "    if(CDFlag /= 0) then\n",
      "       if(ZS_CD /= ZE_CD) then\n",
      "          ZSL_CD = nzS(id)\n",
      "          ZEL_CD = nzE(id)\n",
      "          if(nzS(id) <= ZS_CD) then\n",
      "             ZSL_CD = ZS_CD\n",
      "          end if\n",
      "          if(ZE_CD-1 <= nzE(id)) then\n",
      "             ZEL_CD = ZE_CD-1\n",
      "          end if\n",
      "       end if\n",
      "       if((XS_CD == XE_CD).and.(YS_CD /= YE_CD).and.(ZS_CD /= ZE_CD)) then\n",
      "          if(ZSL_CD <= ZEL_CD) then\n",
      "             allocate(Jy(YS_CD:YE_CD-1, ZSL_CD:ZEL_CD, 1:freqPoint_CD))\n",
      "             allocate(Jz(YS_CD:YE_CD-1, ZSL_CD:ZEL_CD, 1:freqPoint_CD))\n",
      "             Jy = dcmplx(0.0d0, 0.0d0); Jz = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       elseif((XS_CD /= XE_CD).and.(YS_CD == YE_CD).and.(ZS_CD /= ZE_CD)) then\n",
      "          if(ZSL_CD <= ZEL_CD) then\n",
      "             allocate(Jx(XS_CD:XE_CD-1, ZSL_CD:ZEL_CD, 1:freqPoint_CD))\n",
      "             allocate(Jz(XS_CD:XE_CD-1, ZSL_CD:ZEL_CD, 1:freqPoint_CD))\n",
      "             Jx = dcmplx(0.0d0, 0.0d0); Jz = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       elseif((XS_CD /= XE_CD).and.(YS_CD /= YE_CD).and.(ZS_CD == ZE_CD)) then\n",
      "          if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "             allocate(Jx(XS_CD:XE_CD-1, YS_CD:YE_CD-1, 1:freqPoint_CD))\n",
      "             allocate(Jy(XS_CD:XE_CD-1, YS_CD:YE_CD-1, 1:freqPoint_CD))\n",
      "             Jx = dcmplx(0.0d0, 0.0d0); Jy = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       elseif((YS_CD == YE_CD).and.(ZS_CD == ZE_CD)) then\n",
      "          if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "             allocate(Jl(XS_CD:XE_CD-1, 1:freqPoint_CD))\n",
      "             Jl = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       elseif((XS_CD == XE_CD).and.(ZS_CD == ZE_CD)) then\n",
      "          if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "             allocate(Jl(YS_CD:YE_CD-1, 1:freqPoint_CD))\n",
      "             Jl = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       elseif((XS_CD == XE_CD).and.(YS_CD == YE_CD)) then\n",
      "          if(ZSL_CD <= ZEL_CD) then\n",
      "             allocate(Jl(ZSL_CD:ZEL_CD, 1:freqPoint_CD))\n",
      "             Jl = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       end if\n",
      "    end if\n",
      "    if(EDFlag /= 0) then\n",
      "       if(ZS_ED /= ZE_ED) then\n",
      "          ZSL_ED = nzS(id)\n",
      "          ZEL_ED = nzE(id)\n",
      "          if(nzS(id) <= ZS_ED) then\n",
      "             ZSL_ED = ZS_ED\n",
      "          end if\n",
      "          if(ZE_ED-1 <= nzE(id)) then\n",
      "             ZEL_ED = ZE_ED-1\n",
      "          end if\n",
      "       end if\n",
      "       if(XS_ED == XE_ED) then\n",
      "          if(ZSL_ED <= ZEL_ED) then\n",
      "             allocate(Ey_ED(YS_ED:YE_ED-1, ZSL_ED:ZEL_ED, 1:freqPoint_ED))\n",
      "             allocate(Ez_ED(YS_ED:YE_ED-1, ZSL_ED:ZEL_ED, 1:freqPoint_ED))\n",
      "             Ey_ED = dcmplx(0.0d0, 0.0d0); Ez_ED = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       else if(YS_ED == YE_ED) then\n",
      "          if(ZSL_ED <= ZEL_ED) then\n",
      "             allocate(Ex_ED(XS_ED:XE_ED-1, ZSL_ED:ZEL_ED, 1:freqPoint_ED))\n",
      "             allocate(Ez_ED(XS_ED:XE_ED-1, ZSL_ED:ZEL_ED, 1:freqPoint_ED))\n",
      "             Ex_ED = dcmplx(0.0d0, 0.0d0); Ez_ED = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       else if(ZS_ED == ZE_ED) then\n",
      "          if(nzS(id) <= ZS_ED .and. ZS_ED <= nzE(id)) then\n",
      "             allocate(Ex_ED(XS_ED:XE_ED-1, YS_ED:YE_ED-1, 1:freqPoint_ED))\n",
      "             allocate(Ey_ED(XS_ED:XE_ED-1, YS_ED:YE_ED-1, 1:freqPoint_ED))\n",
      "             Ex_ED = dcmplx(0.0d0, 0.0d0); Ey_ED = dcmplx(0.0d0, 0.0d0)\n",
      "          end if\n",
      "       end if\n",
      "    end if\n",
      "  end subroutine initialize\n",
      "  subroutine calc_feed\n",
      "    integer :: i,x,y,z\n",
      "\n",
      "    do i=1, nfeed\n",
      "       select case(feedType(i))\n",
      "       case(0)\n",
      "          Vt(i) = gauss_pulse(dt*dble(t), feedTAU(i), feedALPHA(i), feedAMP(i))\n",
      "       case(1)\n",
      "          Vt(i) = d_gauss_pulse(dt*dble(t), feedTAU(i), feedALPHA(i), feedAMP(i))\n",
      "       case default\n",
      "       end select\n",
      "       Vt(i) = Vt(i) - feedR(i)*It(i)\n",
      "       select case (feedAxis(i))\n",
      "       case('x')\n",
      "          if((nzS(id) <= feedz(i)) .and. (feedz(i) <= nzE(id))) then\n",
      "             do x=feedx(i), feedx(i)+(feedLength(i)-1)*feedSign(i), feedSign(i)\n",
      "                Ex(x,feedy(i),feedz(i)) &\n",
      "                     & = dble(-feedSign(i))*Vt(i)/dx/dble(feedLength(i))\n",
      "             end do\n",
      "          end if\n",
      "       case('y')\n",
      "          if((nzS(id) <= feedz(i)) .and. (feedz(i) <= nzE(id))) then\n",
      "             do y=feedy(i), feedy(i)+(feedLength(i)-1)*feedSign(i), feedSign(i)\n",
      "                Ey(feedx(i),y,feedz(i)) &\n",
      "                     & = dble(-feedSign(i))*Vt(i)/dy/dble(feedLength(i))\n",
      "             end do\n",
      "          end if\n",
      "       case('z')\n",
      "          do z=feedz(i), feedz(i)+(feedLength(i)-1)*feedSign(i), feedSign(i)\n",
      "             if((nzS(id) <= z) .and. (z <= nzE(id))) then\n",
      "                Ez(feedx(i),feedy(i),z) &\n",
      "                     & = dble(-feedSign(i))*Vt(i)/dz/dble(feedLength(i))\n",
      "             end if\n",
      "          end do\n",
      "       end select\n",
      "    enddo\n",
      "  end subroutine calc_feed\n",
      "  subroutine calc_E(k)\n",
      "    integer :: i, j, k\n",
      "    if(k <= LM) then\n",
      "       do j=2, ny\n",
      "          do i=2, nx\n",
      "             Ezx1(i,j,k) = CpmlEdx(i)*Ezx1(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hy(i,j,k)-Hy(i-1,j,k))\n",
      "             Ezy1(i,j,k) = CpmlEdy(j)*Ezy1(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hx(i,j-1,k)-Hx(i,j,k))\n",
      "             Ez(i,j,k) = Ezx1(i,j,k) + Ezy1(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       if(k >= 2) then\n",
      "          do j=1, ny\n",
      "             do i=2, nx\n",
      "                Eyx1(i,j,k) = CpmlEdx(i)*Eyx1(i,j,k) &\n",
      "                     & + CpmlEdxL(i)*(Hz(i-1,j,k)-Hz(i,j,k))\n",
      "                Eyz1(i,j,k) = CpmlEdz(k)*Eyz1(i,j,k) &\n",
      "                     & + CpmlEdzL(k)*(Hx(i,j,k)-Hx(i,j,k-1))\n",
      "                Ey(i,j,k) = Eyx1(i,j,k) + Eyz1(i,j,k)\n",
      "             enddo\n",
      "          enddo\n",
      "          do j=2, ny\n",
      "             do i=1, nx\n",
      "                Exy1(i,j,k) = CpmlEdy(j)*Exy1(i,j,k) &\n",
      "                     & + CpmlEdyL(j)*(Hz(i,j,k)-Hz(i,j-1,k))\n",
      "                Exz1(i,j,k) = CpmlEdz(k)*Exz1(i,j,k) &\n",
      "                     & + CpmlEdzL(k)*(Hy(i,j,k-1)-Hy(i,j,k))\n",
      "                Ex(i,j,k) = Exy1(i,j,k) + Exz1(i,j,k)\n",
      "             enddo\n",
      "          enddo\n",
      "       endif\n",
      "    else if(k >= nz-LM+1) then\n",
      "       do j=2, ny\n",
      "          do i=2, nx\n",
      "             Ezx2(i,j,k) = CpmlEdx(i)*Ezx2(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hy(i,j,k)-Hy(i-1,j,k))\n",
      "             Ezy2(i,j,k) = CpmlEdy(j)*Ezy2(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hx(i,j-1,k)-Hx(i,j,k))\n",
      "             Ez(i,j,k) = Ezx2(i,j,k) + Ezy2(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=1, ny\n",
      "          do i=2, nx\n",
      "             Eyx2(i,j,k) = CpmlEdx(i)*Eyx2(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hz(i-1,j,k)-Hz(i,j,k))\n",
      "             Eyz2(i,j,k) = CpmlEdz(k)*Eyz2(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hx(i,j,k)-Hx(i,j,k-1))\n",
      "             Ey(i,j,k) = Eyx2(i,j,k) + Eyz2(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=2, ny\n",
      "          do i=1, nx\n",
      "             Exy2(i,j,k) = CpmlEdy(j)*Exy2(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hz(i,j,k)-Hz(i,j-1,k))\n",
      "             Exz2(i,j,k) = CpmlEdz(k)*Exz2(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hy(i,j,k-1)-Hy(i,j,k))\n",
      "             Ex(i,j,k) = Exy2(i,j,k) + Exz2(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "    else\n",
      "       do j=2, LM\n",
      "          do i=2, nx\n",
      "             Ezx3(i,j,k) = CpmlEdx(i)*Ezx3(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hy(i,j,k)-Hy(i-1,j,k))\n",
      "             Ezy3(i,j,k) = CpmlEdy(j)*Ezy3(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hx(i,j-1,k)-Hx(i,j,k))\n",
      "             Ez(i,j,k) = Ezx3(i,j,k) + Ezy3(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=LM+1, ny-LM\n",
      "          do i=2, LM\n",
      "             Ezx5(i,j,k) = CpmlEdx(i)*Ezx5(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hy(i,j,k)-Hy(i-1,j,k))\n",
      "             Ezy5(i,j,k) = CpmlEdy(j)*Ezy5(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hx(i,j-1,k)-Hx(i,j,k))\n",
      "             Ez(i,j,k) = Ezx5(i,j,k) + Ezy5(i,j,k)\n",
      "          enddo\n",
      "          do i=LM+1, nx-LM\n",
      "             Ez(i,j,k) = CEz(IDEz(i,j,k))*Ez(i,j,k) &\n",
      "                  & + CEzLx(IDEz(i,j,k))*(Hy(i,j,k)-Hy(i-1,j,k)) &\n",
      "                  & - CEzLy(IDEz(i,j,k))*(Hx(i,j,k)-Hx(i,j-1,k))\n",
      "          enddo\n",
      "          do i=nx-LM+1, nx\n",
      "             Ezx6(i,j,k) = CpmlEdx(i)*Ezx6(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hy(i,j,k)-Hy(i-1,j,k))\n",
      "             Ezy6(i,j,k) = CpmlEdy(j)*Ezy6(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hx(i,j-1,k)-Hx(i,j,k))\n",
      "             Ez(i,j,k) = Ezx6(i,j,k) + Ezy6(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-LM+1, ny\n",
      "          do i=2, nx\n",
      "             Ezx4(i,j,k) = CpmlEdx(i)*Ezx4(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hy(i,j,k)-Hy(i-1,j,k))\n",
      "             Ezy4(i,j,k) = CpmlEdy(j)*Ezy4(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hx(i,j-1,k)-Hx(i,j,k))\n",
      "             Ez(i,j,k) = Ezx4(i,j,k) + Ezy4(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=1, LM\n",
      "          do i=2, nx\n",
      "             Eyx3(i,j,k) = CpmlEdx(i)*Eyx3(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hz(i-1,j,k)-Hz(i,j,k))\n",
      "             Eyz3(i,j,k) = CpmlEdz(k)*Eyz3(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hx(i,j,k)-Hx(i,j,k-1))\n",
      "             Ey(i,j,k) = Eyx3(i,j,k) + Eyz3(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=LM+1, ny-LM\n",
      "          do i=2, LM\n",
      "             Eyx5(i,j,k) = CpmlEdx(i)*Eyx5(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hz(i-1,j,k)-Hz(i,j,k))\n",
      "             Eyz5(i,j,k) = CpmlEdz(k)*Eyz5(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hx(i,j,k)-Hx(i,j,k-1))\n",
      "             Ey(i,j,k) = Eyx5(i,j,k) + Eyz5(i,j,k)\n",
      "          enddo\n",
      "          do i=LM+1, nx-LM\n",
      "             Ey(i,j,k) = CEy(IDEy(i,j,k))*Ey(i,j,k) &\n",
      "                  & + CEyLz(IDEy(i,j,k))*(Hx(i,j,k)-Hx(i,j,k-1)) &\n",
      "                  & - CEyLx(IDEy(i,j,k))*(Hz(i,j,k)-Hz(i-1,j,k))\n",
      "          enddo\n",
      "          do i=nx-LM+1, nx\n",
      "             Eyx6(i,j,k) = CpmlEdx(i)*Eyx6(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hz(i-1,j,k)-Hz(i,j,k))\n",
      "             Eyz6(i,j,k) = CpmlEdz(k)*Eyz6(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hx(i,j,k)-Hx(i,j,k-1))\n",
      "             Ey(i,j,k) = Eyx6(i,j,k) + Eyz6(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-LM+1, ny\n",
      "          do i=2, nx\n",
      "             Eyx4(i,j,k) = CpmlEdx(i)*Eyx4(i,j,k) &\n",
      "                  & + CpmlEdxL(i)*(Hz(i-1,j,k)-Hz(i,j,k))\n",
      "             Eyz4(i,j,k) = CpmlEdz(k)*Eyz4(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hx(i,j,k)-Hx(i,j,k-1))\n",
      "             Ey(i,j,k) = Eyx4(i,j,k) + Eyz4(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=2, LM\n",
      "          do i=1, nx\n",
      "             Exy3(i,j,k) = CpmlEdy(j)*Exy3(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hz(i,j,k)-Hz(i,j-1,k))\n",
      "             Exz3(i,j,k) = CpmlEdz(k)*Exz3(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hy(i,j,k-1)-Hy(i,j,k))\n",
      "             Ex(i,j,k) = Exy3(i,j,k) + Exz3(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=LM+1, ny-LM\n",
      "          do i=1, LM\n",
      "             Exy5(i,j,k) = CpmlEdy(j)*Exy5(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hz(i,j,k)-Hz(i,j-1,k))\n",
      "             Exz5(i,j,k) = CpmlEdz(k)*Exz5(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hy(i,j,k-1)-Hy(i,j,k))\n",
      "             Ex(i,j,k) = Exy5(i,j,k) + Exz5(i,j,k)\n",
      "          enddo\n",
      "          do i=LM+1, nx-LM\n",
      "             Ex(i,j,k) = CEx(IDEx(i,j,k))*Ex(i,j,k) &\n",
      "                  & + CExLy(IDEx(i,j,k))*(Hz(i,j,k)-Hz(i,j-1,k)) &\n",
      "                  & - CExLz(IDEx(i,j,k))*(Hy(i,j,k)-Hy(i,j,k-1))\n",
      "          enddo\n",
      "          do i=nx-LM+1, nx\n",
      "             Exy6(i,j,k) = CpmlEdy(j)*Exy6(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hz(i,j,k)-Hz(i,j-1,k))\n",
      "             Exz6(i,j,k) = CpmlEdz(k)*Exz6(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hy(i,j,k-1)-Hy(i,j,k))\n",
      "             Ex(i,j,k) = Exy6(i,j,k) + Exz6(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-LM+1, ny\n",
      "          do i=1, nx\n",
      "             Exy4(i,j,k) = CpmlEdy(j)*Exy4(i,j,k) &\n",
      "                  & + CpmlEdyL(j)*(Hz(i,j,k)-Hz(i,j-1,k))\n",
      "             Exz4(i,j,k) = CpmlEdz(k)*Exz4(i,j,k) &\n",
      "                  & + CpmlEdzL(k)*(Hy(i,j,k-1)-Hy(i,j,k))\n",
      "             Ex(i,j,k) = Exy4(i,j,k) + Exz4(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "    endif\n",
      "  end subroutine calc_E\n",
      "\n",
      "  subroutine calc_PHI(k)\n",
      "    integer :: i,j,k\n",
      "\n",
      "    if(ZSL_RC <= k .and. k <= ZEL_RC) then\n",
      "       do j=YS_RC, YE_RC\n",
      "          do i=XS_RC, XE_RC\n",
      "             PHIx(i,j,k) = CPhi1(IDEx(i,j,k))*Ex(i,j,k) &\n",
      "                  & + CPhi2(IDEx(i,j,k))*ExSaveRC(i,j,k) &\n",
      "                  & + CPhi3(IDEx(i,j,k))*PHIx(i,j,k)\n",
      "             ExSaveRC(i,j,k) = Ex(i,j,k)\n",
      "             PHIy(i,j,k) = CPhi1(IDEy(i,j,k))*Ey(i,j,k) &\n",
      "                  & + CPhi2(IDEy(i,j,k))*EySaveRC(i,j,k) &\n",
      "                  & + CPhi3(IDEy(i,j,k))*PHIy(i,j,k)\n",
      "             EySaveRC(i,j,k) = Ey(i,j,k)\n",
      "             PHIz(i,j,k) = CPhi1(IDEz(i,j,k))*Ez(i,j,k) &\n",
      "                  & + CPhi2(IDEz(i,j,k))*EzSaveRC(i,j,k) &\n",
      "                  & + CPhi3(IDEz(i,j,k))*PHIz(i,j,k)\n",
      "             EzSaveRC(i,j,k) = Ez(i,j,k)\n",
      "          end do\n",
      "       end do\n",
      "    end if\n",
      "  end subroutine calc_PHI\n",
      "  subroutine E_PHI_update(k)\n",
      "    integer :: i,j,k\n",
      "\n",
      "    if(ZSL_RC <= k .and. k <= ZEL_RC) then\n",
      "       do j=YS_RC, YE_RC\n",
      "          do i=XS_RC, XE_RC\n",
      "             Ex(i,j,k) = Ex(i,j,k) + CPhi(IDEx(i,j,k))*PHIx(i,j,k)\n",
      "             Ey(i,j,k) = Ey(i,j,k) + CPhi(IDEy(i,j,k))*PHIy(i,j,k)\n",
      "             Ez(i,j,k) = Ez(i,j,k) + CPhi(IDEz(i,j,k))*PHIz(i,j,k)\n",
      "          end do\n",
      "       end do\n",
      "    end if\n",
      "  end subroutine E_PHI_update\n",
      "\n",
      "  subroutine calc_H(k)\n",
      "    integer :: i, j, k\n",
      "    if(k <= LM) then\n",
      "       do j=ny-1, 1, -1\n",
      "          do i=nx-1, 1, -1\n",
      "             Hzx1(i,j,k) = CpmlHdx(i)*Hzx1(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ey(i,j,k)-Ey(i+1,j,k))\n",
      "             Hzy1(i,j,k) = CpmlHdy(j)*Hzy1(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "             Hz(i,j,k) = Hzx1(i,j,k) + Hzy1(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny, 1, -1\n",
      "          do i=nx-1, 1, -1\n",
      "             Hyz1(i,j,k) = CpmlHdz(k)*Hyz1(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ex(i,j,k)-Ex(i,j,k+1))\n",
      "             Hyx1(i,j,k) = CpmlHdx(i)*Hyx1(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "             Hy(i,j,k) = Hyz1(i,j,k) + Hyx1(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-1, 1, -1\n",
      "          do i=nx, 1, -1\n",
      "             Hxy1(i,j,k) = CpmlHdy(j)*Hxy1(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ez(i,j,k)-Ez(i,j+1,k))\n",
      "             Hxz1(i,j,k) = CpmlHdz(k)*Hxz1(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "             Hx(i,j,k) = Hxy1(i,j,k) + Hxz1(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "    else if(k >= nz-LM+1) then\n",
      "       do j=ny-1, 1, -1\n",
      "          do i=nx-1, 1, -1\n",
      "             Hzx2(i,j,k) = CpmlHdx(i)*Hzx2(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ey(i,j,k)-Ey(i+1,j,k))\n",
      "             Hzy2(i,j,k) = CpmlHdy(j)*Hzy2(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "             Hz(i,j,k) = Hzx2(i,j,k) + Hzy2(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       if(k <= nz-1) then\n",
      "          do j=ny, 1, -1\n",
      "             do i=nx-1, 1, -1\n",
      "                Hyz2(i,j,k) = CpmlHdz(k)*Hyz2(i,j,k) &\n",
      "                     & + CpmlHdzL(k)*(Ex(i,j,k)-Ex(i,j,k+1))\n",
      "                Hyx2(i,j,k) = CpmlHdx(i)*Hyx2(i,j,k) &\n",
      "                     & + CpmlHdxL(i)*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "                Hy(i,j,k) = Hyz2(i,j,k) + Hyx2(i,j,k)\n",
      "             enddo\n",
      "          enddo\n",
      "          do j=ny-1, 1, -1\n",
      "             do i=nx, 1, -1\n",
      "                Hxy2(i,j,k) = CpmlHdy(j)*Hxy2(i,j,k) &\n",
      "                     & + CpmlHdyL(j)*(Ez(i,j,k)-Ez(i,j+1,k))\n",
      "                Hxz2(i,j,k) = CpmlHdz(k)*Hxz2(i,j,k) &\n",
      "                     & + CpmlHdzL(k)*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "                Hx(i,j,k) = Hxy2(i,j,k) + Hxz2(i,j,k)\n",
      "             enddo\n",
      "          enddo\n",
      "       endif\n",
      "    else\n",
      "       do j=ny-1, ny-LM+1, -1\n",
      "          do i=nx-1, 1, -1\n",
      "             Hzx4(i,j,k) = CpmlHdx(i)*Hzx4(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ey(i,j,k)-Ey(i+1,j,k))\n",
      "             Hzy4(i,j,k) = CpmlHdy(j)*Hzy4(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "             Hz(i,j,k) = Hzx4(i,j,k) + Hzy4(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-LM, LM+1, -1\n",
      "          do i=nx-1, nx-LM+1, -1\n",
      "             Hzx6(i,j,k) = CpmlHdx(i)*Hzx6(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ey(i,j,k)-Ey(i+1,j,k))\n",
      "             Hzy6(i,j,k) = CpmlHdy(j)*Hzy6(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "             Hz(i,j,k) = Hzx6(i,j,k) + Hzy6(i,j,k)\n",
      "          enddo\n",
      "          do i=nx-LM, LM+1, -1\n",
      "             Hz(i,j,k) = Hz(i,j,k) &\n",
      "                  & - CHzLx(IDHy(i,j,k))*(Ey(i+1,j,k)-Ey(i,j,k)) &\n",
      "                  & + CHzLy(IDHy(i,j,k))*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "          enddo\n",
      "          do i=LM, 1, -1\n",
      "             Hzx5(i,j,k) = CpmlHdx(i)*Hzx5(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ey(i,j,k)-Ey(i+1,j,k))\n",
      "             Hzy5(i,j,k) = CpmlHdy(j)*Hzy5(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "             Hz(i,j,k) = Hzx5(i,j,k) + Hzy5(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=LM, 1, -1\n",
      "          do i=nx-1, 1, -1\n",
      "             Hzx3(i,j,k) = CpmlHdx(i)*Hzx3(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ey(i,j,k)-Ey(i+1,j,k))\n",
      "             Hzy3(i,j,k) = CpmlHdy(j)*Hzy3(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "             Hz(i,j,k) = Hzx3(i,j,k) + Hzy3(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny, ny-LM+1, -1\n",
      "          do i=nx-1, 1, -1\n",
      "             Hyz4(i,j,k) = CpmlHdz(k)*Hyz4(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ex(i,j,k)-Ex(i,j,k+1))\n",
      "             Hyx4(i,j,k) = CpmlHdx(i)*Hyx4(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "             Hy(i,j,k) = Hyz4(i,j,k) + Hyx4(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-LM, LM+1, -1\n",
      "          do i=nx-1, nx-LM+1, -1\n",
      "             Hyz6(i,j,k) = CpmlHdz(k)*Hyz6(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ex(i,j,k)-Ex(i,j,k+1))\n",
      "             Hyx6(i,j,k) = CpmlHdx(i)*Hyx6(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "             Hy(i,j,k) = Hyz6(i,j,k) + Hyx6(i,j,k)\n",
      "          enddo\n",
      "          do i=nx-LM, LM+1, -1\n",
      "             Hy(i,j,k) = Hy(i,j,k) &\n",
      "                  & - CHyLz(IDHy(i,j,k))*(Ex(i,j,k+1)-Ex(i,j,k)) &\n",
      "                  & + CHyLx(IDHy(i,j,k))*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "          enddo\n",
      "          do i=LM, 1, -1\n",
      "             Hyz5(i,j,k) = CpmlHdz(k)*Hyz5(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ex(i,j,k)-Ex(i,j,k+1))\n",
      "             Hyx5(i,j,k) = CpmlHdx(i)*Hyx5(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "             Hy(i,j,k) = Hyz5(i,j,k) + Hyx5(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=LM, 1, -1\n",
      "          do i=nx-1, 1, -1\n",
      "             Hyz3(i,j,k) = CpmlHdz(k)*Hyz3(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ex(i,j,k)-Ex(i,j,k+1))\n",
      "             Hyx3(i,j,k) = CpmlHdx(i)*Hyx3(i,j,k) &\n",
      "                  & + CpmlHdxL(i)*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "             Hy(i,j,k) = Hyz3(i,j,k) + Hyx3(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-1, ny-LM+1, -1\n",
      "          do i=nx, 1, -1\n",
      "             Hxy4(i,j,k) = CpmlHdy(j)*Hxy4(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ez(i,j,k)-Ez(i,j+1,k))\n",
      "             Hxz4(i,j,k) = CpmlHdz(k)*Hxz4(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "             Hx(i,j,k) = Hxy4(i,j,k) + Hxz4(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=ny-LM, LM+1, -1\n",
      "          do i=nx, nx-LM+1, -1\n",
      "             Hxy6(i,j,k) = CpmlHdy(j)*Hxy6(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ez(i,j,k)-Ez(i,j+1,k))\n",
      "             Hxz6(i,j,k) = CpmlHdz(k)*Hxz6(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "             Hx(i,j,k) = Hxy6(i,j,k) + Hxz6(i,j,k)\n",
      "          enddo\n",
      "          do i=nx-LM, LM+1, -1\n",
      "             Hx(i,j,k) = Hx(i,j,k) &\n",
      "                  & - CHxLy(IDHx(i,j,k))*(Ez(i,j+1,k)-Ez(i,j,k)) &\n",
      "                  & + CHxLz(IDHx(i,j,k))*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "          enddo\n",
      "          do i=LM, 1, -1\n",
      "             Hxy5(i,j,k) = CpmlHdy(j)*Hxy5(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ez(i,j,k)-Ez(i,j+1,k))\n",
      "             Hxz5(i,j,k) = CpmlHdz(k)*Hxz5(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "             Hx(i,j,k) = Hxy5(i,j,k) + Hxz5(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "       do j=LM, 1, -1\n",
      "          do i=nx, 1, -1\n",
      "             Hxy3(i,j,k) = CpmlHdy(j)*Hxy3(i,j,k) &\n",
      "                  & + CpmlHdyL(j)*(Ez(i,j,k)-Ez(i,j+1,k))\n",
      "             Hxz3(i,j,k) = CpmlHdz(k)*Hxz3(i,j,k) &\n",
      "                  & + CpmlHdzL(k)*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "             Hx(i,j,k) = Hxy3(i,j,k) + Hxz3(i,j,k)\n",
      "          enddo\n",
      "       enddo\n",
      "    endif\n",
      "  end subroutine calc_H\n",
      "\n",
      "  subroutine calc_H_CP(k)\n",
      "    integer :: i,j,k,n\n",
      "\n",
      "    do n = cpS(k), cpE(k)\n",
      "       i = cpX(n)\n",
      "       j = cpY(n)\n",
      "       select case(cpPlaneFlag(n))\n",
      "       case (1)\n",
      "          Hx(i,j,k) = Hx(i,j,k) &\n",
      "               & + CHxLy(IDHx(i,j,k))*(Ez(i,j+1,k)-Ez(i,j,k)) &\n",
      "               & - CHxLz(IDHx(i,j,k))*(Ey(i,j,k+1)-Ey(i,j,k))\n",
      "          Hx(i,j,k) = Hx(i,j,k) &\n",
      "               & - CHCP(n)*(Ez(i,j+1,k)*llz2(n) - Ez(i,j,k)*llz1(n) &\n",
      "               & - Ey(i,j,k+1)*lly2(n) + Ey(i,j,k)*lly1(n))\n",
      "       case (2)\n",
      "          Hy(i,j,k) = Hy(i,j,k) &\n",
      "               & + CHyLz(IDHy(i,j,k))*(Ex(i,j,k+1)-Ex(i,j,k)) &\n",
      "               & - CHyLx(IDHy(i,j,k))*(Ez(i+1,j,k)-Ez(i,j,k))\n",
      "          Hy(i,j,k) = Hy(i,j,k) &\n",
      "               & - CHCP(n)*(Ex(i,j,k+1)*llx2(n) - Ex(i,j,k)*llx1(n) &\n",
      "               & - Ez(i+1,j,k)*llz2(n) + Ez(i,j,k)*llz1(n))\n",
      "       case (3)\n",
      "          Hz(i,j,k) = Hz(i,j,k) &\n",
      "               & + CHzLx(IDHy(i,j,k))*(Ey(i+1,j,k)-Ey(i,j,k))&\n",
      "               & - CHzLy(IDHy(i,j,k))*(Ex(i,j+1,k)-Ex(i,j,k))\n",
      "          Hz(i,j,k) = Hz(i,j,k) &\n",
      "               & - CHCP(n)*(Ey(i+1,j,k)*lly2(n) - Ey(i,j,k)*lly1(n) &\n",
      "               & - Ex(i,j+1,k)*llx2(n) + Ex(i,j,k)*llx1(n))\n",
      "       end select\n",
      "    end do\n",
      "  end subroutine calc_H_CP\n",
      "\n",
      "  subroutine calc_surface_Jm\n",
      "    integer :: f\n",
      "    complex*16 :: CE\n",
      "    real*8 :: m, span\n",
      "\n",
      "    if(freqPoint_pat /= 1) then\n",
      "       span = (freqE_pat - freqS_pat)/dble(freqPoint_pat - 1)/df\n",
      "    end if\n",
      "    if(ZSL_pat <= ZEL_pat) then\n",
      "       m = freqS_pat/df\n",
      "       do f = 1, freqPoint_pat\n",
      "          CE = 0.5d0*dt*exp(dcmplx(0.0,-2.0)*pi*m*dble(t)/dble(nt))\n",
      "          Ey1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ey1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ey(XS_pat,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Ey(XS_pat,YS_pat:YE_pat,ZSL_pat+1:ZEL_pat+1))\n",
      "          Ez1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ez1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ez(XS_pat,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Ez(XS_pat,YS_pat+1:YE_pat+1,ZSL_pat:ZEL_pat))\n",
      "          Ey2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ey2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ey(XE_pat+1,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Ey(XE_pat+1,YS_pat:YE_pat,ZSL_pat+1:ZEL_pat+1))\n",
      "          Ez2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ez2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ez(XE_pat+1,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Ez(XE_pat+1,YS_pat+1:YE_pat+1,ZSL_pat:ZEL_pat))\n",
      "          Ex3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ex3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ex(XS_pat:XE_pat,YS_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Ex(XS_pat:XE_pat,YS_pat,ZSL_pat+1:ZEL_pat+1))\n",
      "          Ez3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ez3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ez(XS_pat:XE_pat,YS_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Ez(XS_pat+1:XE_pat+1,YS_pat,ZSL_pat:ZEL_pat))\n",
      "          Ex4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ex4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ex(XS_pat:XE_pat,YE_pat+1,ZSL_pat:ZEL_pat) &\n",
      "               & + Ex(XS_pat:XE_pat,YE_pat+1,ZSL_pat+1:ZEL_pat+1))\n",
      "          Ez4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Ez4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CE*(Ez(XS_pat:XE_pat,YE_pat+1,ZSL_pat:ZEL_pat) &\n",
      "               & + Ez(XS_pat+1:XE_pat+1,YE_pat+1,ZSL_pat:ZEL_pat))\n",
      "          m = m + span\n",
      "       end do\n",
      "    end if\n",
      "    if((nzS(id) <= ZS_pat) .and. (ZS_pat <= nzE(id))) then\n",
      "       m = freqS_pat/df\n",
      "       do f = 1, freqPoint_pat\n",
      "          CE = 0.5d0*dt*exp(dcmplx(0.0,-2.0)*pi*m*dble(t)/dble(nt))\n",
      "          Ex5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Ex5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CE*(Ex(XS_pat:XE_pat,YS_pat:YE_pat,ZS_pat) &\n",
      "               & + Ex(XS_pat:XE_pat,YS_pat+1:YE_pat+1,ZS_pat))\n",
      "          Ey5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Ey5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CE*(Ey(XS_pat:XE_pat,YS_pat:YE_pat,ZS_pat) &\n",
      "               & + Ey(XS_pat+1:XE_pat+1,YS_pat:YE_pat,ZS_pat))\n",
      "          m = m + span\n",
      "       end do\n",
      "    end if\n",
      "    if((nzS(id) <= ZE_pat+1) .and. (ZE_pat+1 <= nzE(id))) then\n",
      "       m = freqS_pat/df\n",
      "       do f = 1, freqPoint_pat\n",
      "          CE = 0.5d0*dt*exp(dcmplx(0.0,-2.0)*pi*m*dble(t)/dble(nt))\n",
      "          Ex6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Ex6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CE*(Ex(XS_pat:XE_pat,YS_pat:YE_pat,ZE_pat+1) &\n",
      "               & + Ex(XS_pat:XE_pat,YS_pat+1:YE_pat+1,ZE_pat+1))\n",
      "          Ey6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Ey6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CE*(Ey(XS_pat:XE_pat,YS_pat:YE_pat,ZE_pat+1) &\n",
      "               & + Ey(XS_pat+1:XE_pat+1,YS_pat:YE_pat,ZE_pat+1))\n",
      "          m = m + span\n",
      "       end do\n",
      "    end if\n",
      "  end subroutine calc_surface_Jm\n",
      "  subroutine calc_surface_J\n",
      "    integer :: f\n",
      "    complex*16 :: CH\n",
      "    real*8 :: m, span\n",
      "    if(freqPoint_pat /= 1) then\n",
      "       span = (freqE_pat - freqS_pat)/dble(freqPoint_pat - 1)/df\n",
      "    end if\n",
      "    if(ZSL_pat <= ZEL_pat) then\n",
      "       m = freqS_pat/df\n",
      "       do f = 1, freqPoint_pat\n",
      "          CH = 0.5d0*dt*exp(dcmplx(0.0,-2.0)*pi*m*(dble(t)+0.5d0)/dble(nt))\n",
      "          Hy1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hy1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hy(XS_pat,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Hy(XS_pat-1,YS_pat:YE_pat,ZSL_pat:ZEL_pat))\n",
      "          Hz1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hz1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hz(XS_pat,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Hz(XS_pat-1,YS_pat:YE_pat,ZSL_pat:ZEL_pat))\n",
      "          Hy2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hy2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hy(XE_pat+1,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Hy(XE_pat,YS_pat:YE_pat,ZSL_pat:ZEL_pat))\n",
      "          Hz2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hz2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hz(XE_pat+1,YS_pat:YE_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Hz(XE_pat,YS_pat:YE_pat,ZSL_pat:ZEL_pat))\n",
      "          Hx3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hx3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hx(XS_pat:XE_pat,YS_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Hx(XS_pat:XE_pat,YS_pat-1,ZSL_pat:ZEL_pat))\n",
      "          Hz3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hz3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hz(XS_pat:XE_pat,YS_pat,ZSL_pat:ZEL_pat) &\n",
      "               & + Hz(XS_pat:XE_pat,YS_pat-1,ZSL_pat:ZEL_pat))\n",
      "          Hx4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hx4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hx(XS_pat:XE_pat,YE_pat+1,ZSL_pat:ZEL_pat) &\n",
      "               & + Hx(XS_pat:XE_pat,YE_pat,ZSL_pat:ZEL_pat))\n",
      "          Hz4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & = Hz4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & + CH*(Hz(XS_pat:XE_pat,YE_pat+1,ZSL_pat:ZEL_pat) &\n",
      "               & + Hz(XS_pat:XE_pat,YE_pat,ZSL_pat:ZEL_pat))\n",
      "          m = m + span\n",
      "       end do\n",
      "    end if\n",
      "    if((nzS(id) <= ZS_pat) .and. (ZS_pat <= nzE(id))) then\n",
      "       m = freqS_pat/df\n",
      "       do f = 1, freqPoint_pat\n",
      "          CH = 0.5d0*dt*exp(dcmplx(0.0,-2.0)*pi*m*(dble(t)+0.5d0)/dble(nt))\n",
      "          Hx5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Hx5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CH*(Hx(XS_pat:XE_pat,YS_pat:YE_pat,ZS_pat) &\n",
      "               & + Hx(XS_pat:XE_pat,YS_pat:YE_pat,ZS_pat-1))\n",
      "          Hy5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Hy5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CH*(Hy(XS_pat:XE_pat,YS_pat:YE_pat,ZS_pat) &\n",
      "               & + Hy(XS_pat:XE_pat,YS_pat:YE_pat,ZS_pat-1))\n",
      "          m = m + span\n",
      "       end do\n",
      "    end if\n",
      "    if((nzS(id) <= ZE_pat+1) .and. (ZE_pat+1 <= nzE(id))) then\n",
      "       m = freqS_pat/df\n",
      "       do f = 1, freqPoint_pat\n",
      "          CH = 0.5d0*dt*exp(dcmplx(0.0,-2.0)*pi*m*(dble(t)+0.5d0)/dble(nt))\n",
      "          Hx6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Hx6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CH*(Hx(XS_pat:XE_pat,YS_pat:YE_pat,ZE_pat+1) &\n",
      "               & + Hx(XS_pat:XE_pat,YS_pat:YE_pat,ZE_pat))\n",
      "          Hy6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & = Hy6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & + CH*(Hy(XS_pat:XE_pat,YS_pat:YE_pat,ZE_pat+1) &\n",
      "               & + Hy(XS_pat:XE_pat,YS_pat:YE_pat,ZE_pat))\n",
      "          m = m + span\n",
      "       end do\n",
      "    end if\n",
      "  end subroutine calc_surface_J\n",
      "  subroutine calc_I\n",
      "    integer :: i, j\n",
      "    real*8 :: It2, m, span\n",
      "    do i=1, nfeed\n",
      "       if(id == feedNode(i)) then\n",
      "          It2 = It(i)\n",
      "          select case (feedAxis(i))\n",
      "          case('x')\n",
      "             It(i) = dy*(-Hy(feedcx(i), feedcy(i), feedcz(i)) &\n",
      "                  & + Hy(feedcx(i), feedcy(i), feedcz(i)-1)) &\n",
      "                  & + dz*(Hz(feedcx(i), feedcy(i), feedcz(i)) &\n",
      "                  & - Hz(feedcx(i), feedcy(i)-1, feedcz(i)))\n",
      "          case('y')\n",
      "             It(i) = dz*(-Hz(feedcx(i), feedcy(i), feedcz(i)) &\n",
      "                  & + Hz(feedcx(i)-1, feedcy(i), feedcz(i))) &\n",
      "                  & + dx*(Hx(feedcx(i), feedcy(i), feedcz(i)) &\n",
      "                  & - Hx(feedcx(i), feedcy(i), feedcz(i)-1))\n",
      "          case('z')\n",
      "             It(i) = dx*(-Hx(feedcx(i), feedcy(i), feedcz(i)) &\n",
      "                  & + Hx(feedcx(i), feedcy(i)-1, feedcz(i))) &\n",
      "                  & + dy*(Hy(feedcx(i), feedcy(i), feedcz(i)) &\n",
      "                  & - Hy(feedcx(i)-1, feedcy(i), feedcz(i)))\n",
      "          case default\n",
      "          end select\n",
      "          It(i) = It(i)*dble(feedSign(i))\n",
      "          It2 = (It2 + It(i))/2.0d0\n",
      "          if(impedanceFlag /= 0) then\n",
      "             if(freqPoint_imp /= 1) then\n",
      "                span = (freqE_imp - freqS_imp)/dble(freqPoint_imp - 1)/df\n",
      "             end if\n",
      "             m = freqS_imp/df\n",
      "             do j=1, freqPoint_imp\n",
      "                If_imp(j, i) = If_imp(j, i) &\n",
      "                     & + dt*It2*exp(dcmplx(0.0d0,-2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "                Vf_imp(j, i) = Vf_imp(j, i) &\n",
      "                     & + dt*Vt(i)*exp(dcmplx(0.0d0,-2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "                m = m + span\n",
      "             end do\n",
      "          end if\n",
      "          if((patternFlag /= 0) .or. (efficiencyFlag /= 0)) then\n",
      "             if(freqPoint_pat /= 1) then\n",
      "                span = (freqE_pat - freqS_pat)/dble(freqPoint_pat - 1)/df\n",
      "             end if\n",
      "             m = freqS_pat/df\n",
      "             do j=1, freqPoint_pat\n",
      "                If_pat(j, i) = If_pat(j, i) &\n",
      "                     & + dt*It2*exp(dcmplx(0.0d0,-2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "                Vf_pat(j, i) = Vf_pat(j, i) &\n",
      "                     & + dt*Vt(i)*exp(dcmplx(0.0d0,-2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "                m = m + span\n",
      "             end do\n",
      "          endif\n",
      "       else\n",
      "       endif\n",
      "    enddo\n",
      "  end subroutine calc_I\n",
      "  subroutine calc_Pin\n",
      "    integer :: i, f\n",
      "    real*8 :: Pin2(1:freqPoint_pat)\n",
      "    do f=1, freqPoint_pat\n",
      "       Pin(f) = 0.0d0\n",
      "       do i=1, nfeed\n",
      "          Pin(f) = Pin(f) + dble(If_pat(f, i)*conjg(Vf_pat(f, i)))\n",
      "       end do\n",
      "    end do\n",
      "\n",
      "    call MPI_reduce(Pin, Pin2, freqPoint_pat, MPI_DOUBLE_PRECISION, MPI_SUM, &\n",
      "         & 0, MPI_COMM_WORLD, error_code)\n",
      "    if(id == 0) then\n",
      "       Pin = Pin2\n",
      "    end if\n",
      "  end subroutine calc_Pin\n",
      "\n",
      "  subroutine calc_pattern(f, theta, phi, Eth, Eph)\n",
      "    integer :: f\n",
      "    real*8 :: theta, phi\n",
      "    real*8 :: Eth, Eph\n",
      "    real*8 :: Tx,Ty,Tz, Px,Py, Rx,Ry,Rz\n",
      "    real*8 :: dS, RR\n",
      "    real*8 :: freq, lambda, k0\n",
      "    complex*16 :: jk0, CWU\n",
      "    complex*16 :: Wth, Wph, Uth, Uph\n",
      "    complex*16 :: Wth2, Wph2, Uth2, Uph2\n",
      "    integer :: i, j, k\n",
      "    Tx=cos(theta)*cos(phi); Ty=cos(theta)*sin(phi); Tz=-sin(theta)\n",
      "    Px=-sin(phi);           Py=cos(phi)\n",
      "    Rx=sin(theta)*cos(phi); Ry=sin(theta)*sin(phi); Rz=cos(theta)\n",
      "\n",
      "    if(freqPoint_pat /= 1) then\n",
      "       freq = freqS_pat &\n",
      "            & + (freqE_pat - freqS_pat)/dble(freqPoint_pat - 1)*dble(f - 1)\n",
      "    else\n",
      "       freq = freqS_pat\n",
      "    end if\n",
      "    lambda = c/freq\n",
      "    k0 = 2.0d0*pi/lambda\n",
      "    jk0 = dcmplx(0.0d0,k0)\n",
      "    \n",
      "    Wth = dcmplx(0.0d0, 0.0d0)\n",
      "    Wph = Wth\n",
      "    Uth = Wth\n",
      "    Uph = Wth\n",
      "\n",
      "    if(ZSL_pat <= ZEL_pat) then\n",
      "       dS = dy*dz\n",
      "       do k = ZSL_pat, ZEL_pat\n",
      "          do j = YS_pat, YE_pat\n",
      "             RR = dble(XS_pat)*dx*Rx &\n",
      "                  & + (dble(j)+0.5d0)*dy*Ry &\n",
      "                  & + (dble(k)+0.5d0)*dz*Rz\n",
      "             CWU = exp(jk0*RR)*dS\n",
      "             Wth = Wth - CWU*(Hy1(j,k,f)*Tz-Hz1(j,k,f)*Ty)\n",
      "             Wph = Wph + CWU*Hz1(j,k,f)*Py\n",
      "             Uth = Uth + CWU*(Ey1(j,k,f)*Tz-Ez1(j,k,f)*Ty)\n",
      "             Uph = Uph - CWU*Ez1(j,k,f)*Py\n",
      "          enddo\n",
      "       enddo\n",
      "       do k = ZSL_pat, ZEL_pat\n",
      "          do j = YS_pat, YE_pat\n",
      "             RR = dble(XE_pat+1)*dx*Rx &\n",
      "                  & + (dble(j)+0.5d0)*dy*Ry &\n",
      "                  & + (dble(k)+0.5d0)*dz*Rz\n",
      "             CWU = exp(jk0*RR)*dS\n",
      "             Wth = Wth + CWU*(Hy2(j,k,f)*Tz-Hz2(j,k,f)*Ty)\n",
      "             Wph = Wph - CWU*Hz2(j,k,f)*Py\n",
      "             Uth = Uth - CWU*(Ey2(j,k,f)*Tz-Ez2(j,k,f)*Ty)\n",
      "             Uph = Uph + CWU*Ez2(j,k,f)*Py\n",
      "          enddo\n",
      "       enddo\n",
      "       dS = dz*dx\n",
      "       do k = ZSL_pat, ZEL_pat\n",
      "          do i = XS_pat, XE_pat\n",
      "             RR = (dble(i)+0.5d0)*dx*Rx &\n",
      "                  & + dble(YS_pat)*dy*Ry &\n",
      "                  & + (dble(k)+0.5d0)*dz*Rz\n",
      "             CWU = exp(jk0*RR)*dS\n",
      "             Wth = Wth - CWU*(Hz3(i,k,f)*Tx-Hx3(i,k,f)*Tz)\n",
      "             Wph = Wph - CWU*Hz3(i,k,f)*Px\n",
      "             Uth = Uth + CWU*(Ez3(i,k,f)*Tx-Ex3(i,k,f)*Tz)\n",
      "             Uph = Uph + CWU*Ez3(i,k,f)*Px\n",
      "          enddo\n",
      "       enddo\n",
      "       do k = ZSL_pat, ZEL_pat\n",
      "          do i = XS_pat, XE_pat\n",
      "             RR = (dble(i)+0.5d0)*dx*Rx &\n",
      "                  & + dble(YE_pat+1)*dy*Ry &\n",
      "                  & + (dble(k)+0.5d0)*dz*Rz\n",
      "             CWU = exp(jk0*RR)*dS\n",
      "             Wth = Wth + CWU*(Hz4(i,k,f)*Tx-Hx4(i,k,f)*Tz)\n",
      "             Wph = Wph + CWU*Hz4(i,k,f)*Px\n",
      "             Uth = Uth - CWU*(Ez4(i,k,f)*Tx-Ex4(i,k,f)*Tz)\n",
      "             Uph = Uph - CWU*Ez4(i,k,f)*Px\n",
      "          enddo\n",
      "       enddo\n",
      "    end if\n",
      "\n",
      "    dS = dx*dy\n",
      "    if((nzS(id) <= ZS_pat) .and. (ZS_pat <= nzE(id))) then\n",
      "       do j = YS_pat, YE_pat\n",
      "          do i = XS_pat, XE_pat\n",
      "             RR = (dble(i)+0.5d0)*dx*Rx &\n",
      "                  & + (dble(j)+0.5d0)*dy*Ry &\n",
      "                  & + dble(ZS_pat)*dz*Rz\n",
      "             CWU = exp(jk0*RR)*dS\n",
      "             Wth = Wth - CWU*(Hx5(i,j,f)*Ty-Hy5(i,j,f)*Tx)\n",
      "             Wph = Wph + CWU*(Hy5(i,j,f)*Px-Hx5(i,j,f)*Py)\n",
      "             Uth = Uth + CWU*(Ex5(i,j,f)*Ty-Ey5(i,j,f)*Tx)\n",
      "             Uph = Uph - CWU*(Ey5(i,j,f)*Px-Ex5(i,j,f)*Py)\n",
      "          enddo\n",
      "       enddo\n",
      "    end if\n",
      "    if((nzS(id) <= ZE_pat+1) .and. (ZE_pat+1 <= nzE(id))) then\n",
      "       do j = YS_pat, YE_pat\n",
      "          do i = XS_pat, XE_pat\n",
      "             RR = (dble(i)+0.5d0)*dx*Rx &\n",
      "                  & + (dble(j)+0.5d0)*dy*Ry &\n",
      "                  & + dble(ZE_pat+1)*dz*Rz\n",
      "             CWU = exp(jk0*RR)*dS\n",
      "             Wth = Wth + CWU*(Hx6(i,j,f)*Ty-Hy6(i,j,f)*Tx)\n",
      "             Wph = Wph - CWU*(Hy6(i,j,f)*Px-Hx6(i,j,f)*Py)\n",
      "             Uth = Uth - CWU*(Ex6(i,j,f)*Ty-Ey6(i,j,f)*Tx)\n",
      "             Uph = Uph + CWU*(Ey6(i,j,f)*Px-Ex6(i,j,f)*Py)\n",
      "          enddo\n",
      "       enddo\n",
      "    end if\n",
      "\n",
      "    RR = XC_pat*dx*Rx + YC_pat*dy*Ry + ZC_pat*dx*Rz\n",
      "    CWU = jk0/(4.0d0*pi)*exp(-jk0*RR)\n",
      "    Wth = CWU * Wth\n",
      "    Wph = CWU * Wph\n",
      "    Uth = CWU * Uth\n",
      "    Uph = CWU * Uph\n",
      "\n",
      "    call MPI_reduce(Wth, Wth2, 1, MPI_DOUBLE_COMPLEX, MPI_SUM, &\n",
      "         & 0, MPI_COMM_WORLD, error_code)\n",
      "    call MPI_reduce(Wph, Wph2, 1, MPI_DOUBLE_COMPLEX, MPI_SUM, &\n",
      "         & 0, MPI_COMM_WORLD, error_code)\n",
      "    call MPI_reduce(Uth, Uth2, 1, MPI_DOUBLE_COMPLEX, MPI_SUM, &\n",
      "         & 0, MPI_COMM_WORLD, error_code)\n",
      "    call MPI_reduce(Uph, Uph2, 1, MPI_DOUBLE_COMPLEX, MPI_SUM, &\n",
      "         & 0, MPI_COMM_WORLD, error_code)\n",
      "    if(id == 0) then\n",
      "       Eth = abs(-Z0*Wth2-Uph2)\n",
      "       Eph = abs(-Z0*Wph2+Uth2)\n",
      "    end if\n",
      "  end subroutine calc_pattern\n",
      "\n",
      "  subroutine calc_Current_Distribution\n",
      "    integer :: i,j,k,f\n",
      "    real*8 :: m, span\n",
      "    complex*16 :: CJ\n",
      "\n",
      "    if(freqPoint_CD /= 1) then\n",
      "       span = (freqE_CD - freqS_CD)/dble(freqPoint_CD-1)/df\n",
      "    end if\n",
      "    if((XS_CD == XE_CD).and.(YS_CD /= YE_CD) .and.(ZS_CD /= ZE_CD)) then\n",
      "       i = XS_CD\n",
      "       if(ZSL_CD <= ZEL_CD) then\n",
      "          m = freqS_CD/df\n",
      "          do f=1, freqPoint_CD\n",
      "             CJ = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do k=ZSL_CD, ZEL_CD\n",
      "                do j=YS_CD, YE_CD\n",
      "                   if(j .ne. YE_CD) then\n",
      "                      Jy(j,k,f) = Jy(j,k,f) + CJ*Hz(i,j,k)\n",
      "                      Jz(j,k,f) = Jz(j,k,f) + CJ*Hy(i,j,k)\n",
      "                   end if\n",
      "                end do\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    elseif((XS_CD /= XE_CD).and.(YS_CD == YE_CD).and.(ZS_CD /= ZE_CD)) then\n",
      "       j = YS_CD\n",
      "       if(ZSL_CD <= ZEL_CD) then\n",
      "          m = freqS_CD/df\n",
      "          do f=1, freqPoint_CD\n",
      "             CJ = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do k=ZSL_CD, ZEL_CD\n",
      "                do i=XS_CD, XE_CD\n",
      "                   if(i .ne. XE_CD) then\n",
      "                      Jx(i,k,f) = Jx(i,k,f) + CJ*Hz(i,j,k)\n",
      "                      Jz(i,k,f) = Jz(i,k,f) + CJ*Hx(i,j,k)\n",
      "                   end if\n",
      "                end do\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    elseif((XS_CD /= XE_CD).and.(YS_CD /= YE_CD).and.(ZS_CD == ZE_CD)) then\n",
      "       k = ZS_CD\n",
      "       if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "          m = freqS_CD/df\n",
      "          do f=1, freqPoint_CD\n",
      "             CJ = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do j=YS_CD, YE_CD\n",
      "                if(j .ne. YE_CD) then\n",
      "                   do i=XS_CD, XE_CD\n",
      "                      if(i .ne. XE_CD) then\n",
      "                         Jx(i,j,f) = Jx(i,j,f) + CJ*Hy(i,j,k)\n",
      "                         Jy(i,j,f) = Jy(i,j,f) + CJ*Hx(i,j,k)\n",
      "                      end if\n",
      "                   end do\n",
      "                end if\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    elseif((YS_CD == YE_CD) .and. (ZS_CD == ZE_CD)) then\n",
      "       j = YS_CD\n",
      "       k = ZS_CD\n",
      "       if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "          m = freqS_CD/df\n",
      "          do f=1, freqPoint_CD\n",
      "             CJ = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do i = XS_CD, XE_CD\n",
      "                if(i .ne. XE_CD) then\n",
      "                   Jl(i,f) = Jl(i,f) + CJ*(dy*(-Hy(i,j,k) + Hy(i,j,k-1)) &\n",
      "                        & + dz*(Hz(i,j,k) - Hz(i,j-1,k)))\n",
      "                end if\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    elseif((XS_CD == XE_CD) .and. (ZS_CD == ZE_CD)) then\n",
      "       i = XS_CD\n",
      "       k = ZS_CD\n",
      "       if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "          m = freqS_CD/df\n",
      "          do f=1, freqPoint_CD\n",
      "             CJ = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do j = YS_CD, YE_CD\n",
      "                if(j .ne. YE_CD) then\n",
      "                   Jl(j,f) = Jl(j,f) + CJ*(dz*(-Hz(i,j,k) + Hz(i-1,j,k)) &\n",
      "                        & + dx*(Hx(i,j,k) - Hx(i,j,k-1)))\n",
      "                end if\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    elseif((XS_CD == XE_CD) .and. (YS_CD == YE_CD)) then\n",
      "       i = XS_CD\n",
      "       j = YS_CD\n",
      "       if(ZSL_CD <= ZEL_CD) then\n",
      "          m = freqS_CD/df\n",
      "          do f=1, freqPoint_CD\n",
      "             CJ = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do k=ZSL_CD, ZEL_CD\n",
      "                Jl(k,f) = Jl(k,f) + CJ*(dx*(-Hx(i,j,k) + Hx(i,j-1,k)) &\n",
      "                     & + dy*(Hy(i,j,k) - Hy(i-1,j,k)))\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    end if\n",
      "  end subroutine calc_Current_Distribution\n",
      "\n",
      "  subroutine calc_Electric_Field_Distribution\n",
      "    integer :: i,j,k,f\n",
      "    real*8 :: m, span\n",
      "    complex*16 :: CE\n",
      "\n",
      "    if(freqPoint_ED /= 1) then\n",
      "       span = (freqE_ED - freqS_ED)/dble(freqPoint_ED-1)/df\n",
      "    end if\n",
      "    if(XS_ED == XE_ED) then\n",
      "       i = XS_ED\n",
      "       if(ZSL_ED <= ZEL_ED) then\n",
      "          m = freqS_ED/df\n",
      "          do f=1, freqPoint_ED\n",
      "             CE = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do k=ZSL_ED, ZEL_ED\n",
      "                do j=YS_ED, YE_ED\n",
      "                   if(j .ne. YE_ED) then\n",
      "                      Ey_ED(j,k,f) = Ey_ED(j,k,f) + CE*Ey(i,j,k)\n",
      "                      Ez_ED(j,k,f) = Ez_ED(j,k,f) + CE*Ez(i,j,k)\n",
      "                   end if\n",
      "                end do\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    else if(YS_ED == YE_ED) then\n",
      "       j = YS_ED\n",
      "       if(ZSL_ED <= ZEL_ED) then\n",
      "          m = freqS_ED/df\n",
      "          do f=1, freqPoint_ED\n",
      "             CE = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do k=ZSL_ED, ZEL_ED\n",
      "                do i=XS_ED, XE_ED\n",
      "                   if(i .ne. XE_ED) then\n",
      "                      Ex_ED(i,k,f) = Ex_ED(i,k,f) + CE*Ex(i,j,k)\n",
      "                      Ez_ED(i,k,f) = Ez_ED(i,k,f) + CE*Ez(i,j,k)\n",
      "                   end if\n",
      "                end do\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    else if(ZS_ED == ZE_ED) then\n",
      "       k = ZS_ED\n",
      "       if(nzS(id) <= ZS_ED .and. ZS_ED <= nzE(id)) then\n",
      "          m = freqS_ED/df\n",
      "          do f=1, freqPoint_ED\n",
      "             CE = exp(dcmplx(0.0d0, -2.0d0)*pi*m*dble(t)/dble(nt))\n",
      "             do j=YS_ED, YE_ED\n",
      "                if(j .ne. YE_ED) then\n",
      "                   do i=XS_ED, XE_ED\n",
      "                      if(i .ne. XE_ED) then\n",
      "                         Ex_ED(i,j,f) = Ex_ED(i,j,f) + CE*Ex(i,j,k)\n",
      "                         Ey_ED(i,j,f) = Ey_ED(i,j,f) + CE*Ey(i,j,k)\n",
      "                      end if\n",
      "                   end do\n",
      "                end if\n",
      "             end do\n",
      "             m = m + span\n",
      "          end do\n",
      "       end if\n",
      "    end if\n",
      "  end subroutine calc_Electric_Field_Distribution\n",
      "\n",
      "  real*8 function gauss_pulse(x, t0, alpha, amp)\n",
      "    real*8 :: x, t0, alpha, amp\n",
      "    if((x >= 0.0d0).and.(x <= 2.0d0*t0)) then\n",
      "       gauss_pulse = exp(-alpha*((x-t0)*(x-t0)))*amp\n",
      "    else\n",
      "       gauss_pulse = 0.0d0\n",
      "    endif\n",
      "  end function gauss_pulse\n",
      "  real*8 function d_gauss_pulse(x, t0, alpha, amp)\n",
      "    real*8 :: x, t0, alpha, amp\n",
      "    if((x >= 0.0d0).and.(x <= 2.0d0*t0)) then\n",
      "       d_gauss_pulse = (x-t0)*exp(-alpha*((x-t0)*(x-t0)))*amp/t0\n",
      "    else\n",
      "       d_gauss_pulse = 0.0d0\n",
      "    endif\n",
      "  end function d_gauss_pulse\n",
      "  real*8 function sin_pulse(x, t0, amp)\n",
      "    real*8 :: x, t0, amp\n",
      "    sin_pulse = amp*sin(2.0d0*pi*x/t0)\n",
      "  end function sin_pulse\n",
      "end module fdtd\n",
      "module output\n",
      "  use setup\n",
      "  use fdtd\n",
      "  implicit none\n",
      "contains\n",
      "  subroutine out_impedance\n",
      "    integer :: i,j\n",
      "    real*8 :: f,span\n",
      "    complex*16 :: ref\n",
      "\n",
      "    if(id == 0) then\n",
      "       call progress_bar('Impedance calculation', 0, freqPoint_imp, 0, 0, 20)\n",
      "       open(150, file = trim(filename)//'_imp.txt',status='replace')\n",
      "       close(150)\n",
      "       open(151, file = trim(filename)//'_VSWR.txt',status='replace')\n",
      "       close(151)\n",
      "    end if\n",
      "\n",
      "    f = freqS_imp\n",
      "    if(freqPoint_imp /= 1) then\n",
      "       span = (freqE_imp - freqS_imp)/dble(freqPoint_imp - 1)\n",
      "    else\n",
      "       span = 0.0d0\n",
      "    end if\n",
      "\n",
      "    do j=1, freqPoint_imp\n",
      "       if(id == 0) then\n",
      "          open(150, file=trim(filename)//'_imp.txt', &\n",
      "               & status='old', position='append')\n",
      "          write(150,'(G14.4E3,$)') f\n",
      "          close(150)\n",
      "          open(151, file=trim(filename)//'_VSWR.txt', &\n",
      "               & status='old', position='append')\n",
      "          write(151,'(G14.4E3,$)') f\n",
      "          close(151)\n",
      "       end if\n",
      "       call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "       do i=1, nfeed\n",
      "          if((nzS(id) <= feedcz(i)) .and. (feedcz(i) <= nzE(id))) then\n",
      "             imp(j,i) = Vf_imp(j,i)/If_imp(j,i)\n",
      "             open(150, file=trim(filename)//'_imp.txt', &\n",
      "                  & status='old', position='append')\n",
      "             write(150,'(2G14.4E3,$)') dble(imp(j,i)),aimag(imp(j,i))\n",
      "             close(150)\n",
      "             ref = (imp(j,i)-ZL)/(imp(j,i)+ZL)\n",
      "             open(151, file=trim(filename)//'_VSWR.txt', &\n",
      "                  & status='old', position='append')\n",
      "             write(151,'(G14.4E3,$)') (1.0d0+abs(ref))/(1.0d0-abs(ref))\n",
      "             close(151)\n",
      "          end if\n",
      "          call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "       end do\n",
      "       if(id == 0) then\n",
      "          open(150, file=trim(filename)//'_imp.txt', &\n",
      "               & status='old',position='append')\n",
      "          write(150,*)\n",
      "          close(150)\n",
      "          open(151, file=trim(filename)//'_VSWR.txt', &\n",
      "               & status='old',position='append')\n",
      "          write(151,*)\n",
      "          close(151)\n",
      "       end if\n",
      "       f = f + span\n",
      "       if(id == 0) then\n",
      "          call progress_bar('Impedance calculation', j, freqPoint_imp, 0, 0, 20)\n",
      "       end if\n",
      "    end do\n",
      "  end subroutine out_impedance\n",
      "  subroutine out_VI\n",
      "    integer :: i,j\n",
      "    real*8 :: f,span\n",
      "    if(id == 0) then\n",
      "       call progress_bar('VI output', 0, freqPoint_imp, 0, 0, 20)\n",
      "       open(150, file = trim(filename)//'_VI.txt',status='replace')\n",
      "       close(150)\n",
      "    end if\n",
      "    f = freqS_imp\n",
      "    if(freqPoint_imp /= 1) then\n",
      "       span = (freqE_imp - freqS_imp)/dble(freqPoint_imp - 1)\n",
      "    else\n",
      "       span = 0.0d0\n",
      "    end if\n",
      "    do j=1, freqPoint_imp\n",
      "       if(id == 0) then\n",
      "          open(150, file=trim(filename)//'_VI.txt', &\n",
      "               & status='old', position='append')\n",
      "          write(150,'(G14.4E3,$)') f\n",
      "          close(150)\n",
      "       end if\n",
      "       call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "       do i=1, nfeed\n",
      "          if((nzS(id) <= feedcz(i)) .and. (feedcz(i) <= nzE(id))) then\n",
      "             open(150, file=trim(filename)//'_VI.txt', &\n",
      "                  & status='old', position='append')\n",
      "             write(150,'(4G14.4E3,$)') Vf_imp(j,i),If_imp(j,i)\n",
      "             close(150)\n",
      "          end if\n",
      "          call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "       end do\n",
      "       if(id == 0) then\n",
      "          open(150, file=trim(filename)//'_VI.txt', &\n",
      "               & status='old', position='append')\n",
      "          write(150,*)\n",
      "          close(150)\n",
      "       end if\n",
      "       f = f + span\n",
      "       if(id == 0) then\n",
      "          call progress_bar('VI output', j, freqPoint_imp, 0, 0, 20)\n",
      "       end if\n",
      "    end do\n",
      "    call MPI_barrier(MPI_COMM_WORLD, error_code) \n",
      "  end subroutine out_VI\n",
      "  subroutine out_pattern\n",
      "    real*8 :: Eth(1:3), Eph(1:3)\n",
      "    integer :: f, L\n",
      "    if(id == 0) then\n",
      "       call progress_bar('Pattern calculation', 0, freqPoint_pat, 0, 0, 20)\n",
      "       open(150,file=trim(filename)//'_pat.txt')\n",
      "       write(150, '(6E12.4)') freqS_pat, freqE_pat, dble(freqPoint_pat), &\n",
      "            & XC_pat, YC_pat, ZC_pat\n",
      "    end if\n",
      "    do f=1, freqPoint_pat\n",
      "       do L=0, nAngle\n",
      "          call calc_pattern(f, pi/2.0d0, dble(L)/dble(nAngle)*2.0d0*pi, &\n",
      "               & Eth(1), Eph(1))\n",
      "          call calc_pattern(f, -dble(L)/dble(nAngle)*2.0d0*pi+pi/2.0d0, &\n",
      "               & pi/2.0d0, Eth(2), Eph(2))\n",
      "          call calc_pattern(f, dble(L)/dble(nAngle)*2.0d0*pi, 0.0d0, &\n",
      "               & Eth(3), Eph(3))\n",
      "          if(id == 0) then\n",
      "             write(150,'(6E12.4)') Eth(1)*Eth(1)/Pin(f)/30.0d0, &\n",
      "                  & Eph(1)*Eph(1)/Pin(f)/30.0d0, &\n",
      "                  & Eth(2)*Eth(2)/Pin(f)/30.0d0, &\n",
      "                  & Eph(2)*Eph(2)/Pin(f)/30.0d0, &\n",
      "                  & Eth(3)*Eth(3)/Pin(f)/30.0d0, &\n",
      "                  & Eph(3)*Eph(3)/Pin(f)/30.0d0\n",
      "             call progress_bar('Pattern calculation', f, freqPoint_pat, &\n",
      "                  & L+1, nAngle+1, 20)\n",
      "          end if\n",
      "       end do\n",
      "    end do\n",
      "    if(id == 0) then\n",
      "       close(150)\n",
      "    end if\n",
      "  end subroutine out_pattern\n",
      "  subroutine calc_Prad\n",
      "    integer :: f\n",
      "    real*8 :: dS\n",
      "    real*8 :: Prad2(1:freqPoint_pat)\n",
      "\n",
      "    if(id == 0) then\n",
      "       call progress_bar('Efficiency calculation', 0, freqPoint_pat, 0, 0, 20)\n",
      "    end if\n",
      "    Prad = 0.0d0\n",
      "    do f=1, freqPoint_pat\n",
      "       if(ZSL_pat <= ZEL_pat) then\n",
      "          dS = dy*dz\n",
      "          Prad(f) = Prad(f) - sum((dble((Ey1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hz1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f)) &\n",
      "               & - Ez1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hy1(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f)))))*dS)\n",
      "          Prad(f) = Prad(f) + sum((dble((Ey2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hz2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f)) &\n",
      "               & - Ez2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hy2(YS_pat:YE_pat,ZSL_pat:ZEL_pat,f)))))*dS)\n",
      "          dS = dz*dx\n",
      "          Prad(f) = Prad(f) - sum((dble((Ez3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hx3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f)) &\n",
      "               & - Ex3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hz3(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f)))))*dS)\n",
      "          Prad(f) = Prad(f) + sum((dble((Ez4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hx4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f)) &\n",
      "               & - Ex4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f) &\n",
      "               & * conjg(Hz4(XS_pat:XE_pat,ZSL_pat:ZEL_pat,f)))))*dS)\n",
      "          dS = dx*dy\n",
      "       end if\n",
      "       if((nzS(id) <= ZS_pat) .and. (ZS_pat <= nzE(id))) then\n",
      "          Prad(f) = Prad(f) - sum((dble((Ex5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & * conjg(Hy5(XS_pat:XE_pat,YS_pat:YE_pat,f)) &\n",
      "               & - Ey5(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & * conjg(Hx5(XS_pat:XE_pat,YS_pat:YE_pat,f)))))*dS)\n",
      "       end if\n",
      "       if((nzS(id) <= ZE_pat+1) .and. (ZE_pat+1 <= nzE(id))) then\n",
      "          Prad(f) = Prad(f) + sum((dble((Ex6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & * conjg(Hy6(XS_pat:XE_pat,YS_pat:YE_pat,f)) &\n",
      "               & - Ey6(XS_pat:XE_pat,YS_pat:YE_pat,f) &\n",
      "               & * conjg(Hx6(XS_pat:XE_pat,YS_pat:YE_pat,f)))))*dS)\n",
      "       end if\n",
      "       if(id == 0) then\n",
      "          call progress_bar('Efficiency calculation', f, freqPoint_pat, 0, 0, 20)\n",
      "       end if\n",
      "    end do\n",
      "\n",
      "    call MPI_reduce(Prad, Prad2, freqPoint_pat, MPI_DOUBLE_PRECISION, MPI_SUM, &\n",
      "         & 0, MPI_COMM_WORLD, error_code)\n",
      "    if(id == 0) then\n",
      "       Prad = Prad2\n",
      "    end if\n",
      "  end subroutine calc_Prad\n",
      "\n",
      "  subroutine out_efficiency\n",
      "    integer :: f\n",
      "    real*8 :: freq\n",
      "    if(id == 0) then\n",
      "       open(150,file=trim(filename)//'_eff.txt')\n",
      "       do f=1, freqPoint_pat\n",
      "          if(freqPoint_pat /= 1) then\n",
      "             freq = freqS_pat &\n",
      "                  & + (freqE_pat - freqS_pat)/dble(freqPoint_pat - 1)*dble(f - 1)\n",
      "          else\n",
      "             freq = freqS_pat\n",
      "          end if\n",
      "          write(150,'(2E12.4)') freq, Prad(f)/Pin(f)*100.0d0\n",
      "       end do\n",
      "       close(150)\n",
      "    end if\n",
      "  end subroutine out_efficiency\n",
      "\n",
      "  subroutine out_Current_Distribution\n",
      "    integer :: i,j,k,f,p\n",
      "\n",
      "    if(id == 0) then\n",
      "       if (XS_CD /= XE_CD) then\n",
      "          open(150, file = trim(filename)//'_Jx.txt',status='replace')\n",
      "          write(150,'(9E12.4)') dble(XS_CD), dble(YS_CD), dble(ZS_CD), &\n",
      "               & dble(XE_CD), dble(YE_CD), dble(ZE_CD), &\n",
      "               & freqS_CD, freqE_CD, dble(freqPoint_CD)\n",
      "          close(150)\n",
      "       end if\n",
      "       if (YS_CD /= YE_CD) then\n",
      "          open(150, file = trim(filename)//'_Jy.txt',status='replace')\n",
      "          write(150,'(9E12.4)') dble(XS_CD), dble(YS_CD), dble(ZS_CD), &\n",
      "               & dble(XE_CD), dble(YE_CD), dble(ZE_CD), &\n",
      "               & freqS_CD, freqE_CD, dble(freqPoint_CD)\n",
      "          close(150)\n",
      "       end if\n",
      "       if (ZS_CD /= ZE_CD) then\n",
      "          open(150, file = trim(filename)//'_Jz.txt',status='replace')\n",
      "          write(150,'(9E12.4)') dble(XS_CD), dble(YS_CD), dble(ZS_CD), &\n",
      "               & dble(XE_CD), dble(YE_CD), dble(ZE_CD), &\n",
      "               & freqS_CD, freqE_CD, dble(freqPoint_CD)\n",
      "          close(150)\n",
      "       end if\n",
      "    end if\n",
      "    call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "    if((XS_CD == XE_CD).and.(YS_CD /= YE_CD).and.(ZS_CD /= ZE_CD)) then\n",
      "       do f=1, freqPoint_CD\n",
      "          do p=0, np-1\n",
      "             if(p == id) then\n",
      "                if(ZSL_CD <= ZEL_CD) then\n",
      "                   open(150, file=trim(filename)//'_Jy.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   open(151, file=trim(filename)//'_Jz.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   do k=ZSL_CD, ZEL_CD\n",
      "                      do j=YS_CD, YE_CD\n",
      "                         if(j .ne. YE_CD) then\n",
      "                            write(150, '(1E12.4,$)') abs(Jy(j,k,f))\n",
      "                            write(151, '(1E12.4,$)') abs(Jz(j,k,f))\n",
      "                         end if\n",
      "                      end do\n",
      "                      write(150,*) ''\n",
      "                      write(151,*) ''\n",
      "                   end do\n",
      "                   close(150)\n",
      "                   close(151)\n",
      "                end if\n",
      "             end if\n",
      "             call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "          end do\n",
      "       end do\n",
      "    elseif((XS_CD /= XE_CD).and.(YS_CD == YE_CD).and.(ZS_CD /= ZE_CD)) then\n",
      "       do f=1, freqPoint_CD\n",
      "          do p=0, np-1\n",
      "             if(p == id) then\n",
      "                if(ZSL_CD <= ZEL_CD) then\n",
      "                   open(150, file=trim(filename)//'_Jx.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   open(151, file=trim(filename)//'_Jz.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   do k=ZSL_CD, ZEL_CD\n",
      "                      do i=XS_CD, XE_CD\n",
      "                         if (i .ne. XE_CD) then\n",
      "                            write(150, '(1E12.4,$)') abs(Jx(i,k,f))\n",
      "                            write(151, '(1E12.4,$)') abs(Jz(i,k,f))\n",
      "                         end if\n",
      "                      end do\n",
      "                      write(150,*) ''\n",
      "                      write(151,*) ''\n",
      "                   end do\n",
      "                   close(150)\n",
      "                   close(151)\n",
      "                end if\n",
      "             end if\n",
      "             call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "          end do\n",
      "       end do\n",
      "    elseif((XS_CD /= XE_CD).and.(YS_CD /= YE_CD).and.(ZS_CD == ZE_CD)) then\n",
      "       if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "          open(150, file=trim(filename)//'_Jx.txt', &\n",
      "               & status='old',position='append')\n",
      "          open(151, file=trim(filename)//'_Jy.txt', &\n",
      "               & status='old',position='append')\n",
      "          do f=1, freqPoint_CD\n",
      "             do j=YS_CD, YE_CD\n",
      "                if(j .ne. YE_CD) then\n",
      "                   do i=XS_CD, XE_CD\n",
      "                      if(i .ne. XE_CD) then\n",
      "                         write(150, '(1E12.4,$)') abs(Jx(i,j,f))\n",
      "                         write(151, '(1E12.4,$)') abs(Jy(i,j,f))\n",
      "                      end if\n",
      "                   end do\n",
      "                   write(150,*) ''\n",
      "                   write(151,*) ''\n",
      "                end if\n",
      "             end do\n",
      "          end do\n",
      "          close(150)\n",
      "          close(151)\n",
      "       end if\n",
      "    elseif((YS_CD == YE_CD).and.(ZS_CD == ZE_CD)) then\n",
      "       if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "          open(150, file=trim(filename)//'_Jx.txt', &\n",
      "               & status='old',position='append')\n",
      "          do f=1, freqPoint_CD\n",
      "             do i=XS_CD, XE_CD\n",
      "                if(i .ne. XE_CD) then\n",
      "                   write(150, '(1E12.4,$)') abs(Jl(i,f))\n",
      "                end if\n",
      "             end do\n",
      "             write(150,*) ''\n",
      "          end do\n",
      "          close(150)\n",
      "       end if\n",
      "    elseif((XS_CD == XE_CD).and.(ZS_CD == ZE_CD)) then\n",
      "       if(nzS(id) <= ZS_CD .and. ZS_CD <= nzE(id)) then\n",
      "          open(150, file=trim(filename)//'_Jy.txt', &\n",
      "               & status='old',position='append')\n",
      "          do f=1, freqPoint_CD\n",
      "             do j=YS_CD, YE_CD\n",
      "                if(j .ne. YE_CD) then\n",
      "                   write(150, '(1E12.4,$)') abs(Jl(j,f))\n",
      "                end if\n",
      "             end do\n",
      "             write(150,*) ''\n",
      "          end do\n",
      "          close(150)\n",
      "       end if\n",
      "    elseif((XS_CD == XE_CD).and.(YS_CD == YE_CD)) then\n",
      "       do f=1, freqPoint_CD\n",
      "          do p=0, np-1\n",
      "             if(p == id) then\n",
      "                if(ZSL_CD <= ZEL_CD) then\n",
      "                   open(150, file=trim(filename)//'_Jz.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   do k=ZSL_CD, ZEL_CD\n",
      "                      write(150, '(1E12.4,$)') abs(Jl(k,f))\n",
      "                   end do\n",
      "                   close(150)\n",
      "                end if\n",
      "             end if\n",
      "             call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "          end do\n",
      "          if(id == 0) then\n",
      "             open(150, file=trim(filename)//'_Jz.txt', &\n",
      "                  & status='old',position='append')\n",
      "             write(*,*) ''\n",
      "             close(150)\n",
      "          end if\n",
      "          call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "       end do\n",
      "    end if\n",
      "    call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "  end subroutine out_Current_Distribution\n",
      "\n",
      "  subroutine out_Electric_Field_Distribution\n",
      "    integer :: i,j,k,f,p\n",
      "\n",
      "    if(id == 0) then\n",
      "       if (XS_ED /= XE_ED) then\n",
      "          open(150, file = trim(filename)//'_Ex.txt',status='replace')\n",
      "          write(150,'(9E12.4)') dble(XS_ED), dble(YS_ED), dble(ZS_ED), &\n",
      "               & dble(XE_ED), dble(YE_ED), dble(ZE_ED), &\n",
      "               & freqS_ED, freqE_ED, dble(freqPoint_ED)\n",
      "          close(150)\n",
      "       end if\n",
      "       if (YS_ED /= YE_ED) then\n",
      "          open(150, file = trim(filename)//'_Ey.txt',status='replace')\n",
      "          write(150,'(9E12.4)') dble(XS_ED), dble(YS_ED), dble(ZS_ED), &\n",
      "               & dble(XE_ED), dble(YE_ED), dble(ZE_ED), &\n",
      "               & freqS_ED, freqE_ED, dble(freqPoint_ED)\n",
      "          close(150)\n",
      "       end if\n",
      "       if (ZS_ED /= ZE_ED) then\n",
      "          open(150, file = trim(filename)//'_Ez.txt',status='replace')\n",
      "          write(150,'(9E12.4)') dble(XS_ED), dble(YS_ED), dble(ZS_ED), &\n",
      "               & dble(XE_ED), dble(YE_ED), dble(ZE_ED), &\n",
      "               & freqS_ED, freqE_ED, dble(freqPoint_ED)\n",
      "          close(150)\n",
      "       end if\n",
      "    end if\n",
      "    call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "    if(XS_ED == XE_ED) then\n",
      "       do f=1, freqPoint_ED\n",
      "          do p=0, np-1\n",
      "             if(p == id) then\n",
      "                if(ZSL_ED <= ZEL_ED) then\n",
      "                   open(150, file=trim(filename)//'_Ey.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   open(151, file=trim(filename)//'_Ez.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   do k=ZSL_ED, ZEL_ED\n",
      "                      do j=YS_ED, YE_ED\n",
      "                         if(j .ne. YE_ED) then\n",
      "                            write(150, '(1E12.4,$)') abs(Ey_ED(j,k,f))\n",
      "                            write(151, '(1E12.4,$)') abs(Ez_ED(j,k,f))\n",
      "                         end if\n",
      "                      end do\n",
      "                      write(150,*) ''\n",
      "                      write(151,*) ''\n",
      "                   end do\n",
      "                   close(150)\n",
      "                   close(151)\n",
      "                end if\n",
      "             end if\n",
      "             call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "          end do\n",
      "       end do\n",
      "    else if(YS_ED == YE_ED) then\n",
      "       do f=1, freqPoint_ED\n",
      "          do p=0, np-1\n",
      "             if(p == id) then\n",
      "                if(ZSL_ED <= ZEL_ED) then\n",
      "                   open(150, file=trim(filename)//'_Ex.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   open(151, file=trim(filename)//'_Ez.txt', &\n",
      "                        & status='old',position='append')\n",
      "                   do k=ZSL_ED, ZEL_ED\n",
      "                      do i=XS_ED, XE_ED\n",
      "                         if (i .ne. XE_ED) then\n",
      "                            write(150, '(1E12.4,$)') abs(Ex_ED(i,k,f))\n",
      "                            write(151, '(1E12.4,$)') abs(Ez_ED(i,k,f))\n",
      "                         end if\n",
      "                      end do\n",
      "                      write(150,*) ''\n",
      "                      write(151,*) ''\n",
      "                   end do\n",
      "                   close(150)\n",
      "                   close(151)\n",
      "                end if\n",
      "             end if\n",
      "             call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "          end do\n",
      "       end do\n",
      "    else if(ZS_ED == ZE_ED) then\n",
      "       if(nzS(id) <= ZS_ED .and. ZS_ED <= nzE(id)) then\n",
      "          open(150, file=trim(filename)//'_Ex.txt', &\n",
      "               & status='old',position='append')\n",
      "          open(151, file=trim(filename)//'_Ey.txt', &\n",
      "               & status='old',position='append')\n",
      "          do f=1, freqPoint_ED\n",
      "             do j=YS_ED, YE_ED\n",
      "                if(j .ne. YE_ED) then\n",
      "                   do i=XS_ED, XE_ED\n",
      "                      if(i .ne. XE_ED) then\n",
      "                         write(150, '(1E12.4,$)') abs(Ex_ED(i,j,f))\n",
      "                         write(151, '(1E12.4,$)') abs(Ey_ED(i,j,f))\n",
      "                      end if\n",
      "                   end do\n",
      "                   write(150,*) ''\n",
      "                   write(151,*) ''\n",
      "                end if\n",
      "             end do\n",
      "          end do\n",
      "          close(150)\n",
      "          close(151)\n",
      "       end if\n",
      "    end if\n",
      "    call MPI_barrier(MPI_COMM_WORLD, error_code)\n",
      "  end subroutine out_Electric_Field_Distribution\n",
      "\n",
      "  subroutine progress_bar(title, n, max, n_sub, max_sub, bar_length)\n",
      "    character(*) :: title\n",
      "    integer :: n, max, n_sub, max_sub, bar_length\n",
      "    character :: BS!, DEL\n",
      "    character*128 :: tempstr, tempstr2\n",
      "    integer, save :: starttime(8)\n",
      "    integer :: now(8)\n",
      "    real*8 :: elapsed_time\n",
      "    integer :: i\n",
      "\n",
      "    if(n == 0) then\n",
      "       call date_and_time(values=starttime)\n",
      "    end if\n",
      "\n",
      "    BS = char(8)\n",
      "\n",
      "    do i=1, 256\n",
      "       write(*, '(1A$)') BS\n",
      "    end do\n",
      "    write(*, '(1A$)') trim(title)\n",
      "    write(*, '(1A$)') ' ['\n",
      "    do i=0, bar_length*n/max\n",
      "       if(i /= 0) then\n",
      "          write(*, '(1A$)') '*'\n",
      "       end if\n",
      "    end do\n",
      "    do i=bar_length*n/max, bar_length\n",
      "       if (i /= bar_length) then\n",
      "          write(*, '(1A$)')' '\n",
      "       end if\n",
      "    end do\n",
      "    write(tempstr, *) n\n",
      "    write(tempstr2, *) max\n",
      "    tempstr = '] (' // trim(tempstr) // '/' // trim(tempstr2) // ')'\n",
      "    write(*, '(1A$)') trim(tempstr)\n",
      "\n",
      "    call date_and_time(values=now)\n",
      "    elapsed_time = dble((now(3) - starttime(3))*starttime(4)) &\n",
      "         & *24.0d0*60.0d0*60.0d0*1.0d3 &\n",
      "         & + dble(now(4) - starttime(4))*24.0d0*60.0d0*60.0d0*1.0d3 &\n",
      "         & + dble(now(5) - starttime(5))*60.0d0*60.0d0*1.0d3 &\n",
      "         & + dble(now(6) - starttime(6))*60.0d0*1.0d3 &\n",
      "         & + dble(now(7) - starttime(7))*1.0d3 &\n",
      "         & + dble(now(8) - starttime(8))\n",
      "    if(max_sub == 0) then\n",
      "       write(tempstr, *) nint(elapsed_time/1.0d3/dble(n)*dble(max-n))\n",
      "    else\n",
      "       write(tempstr, *) nint(elapsed_time/1.0d3/dble((n-1)*max_sub+n_sub) &\n",
      "            & * dble((max-n)*max_sub+(max_sub-n_sub)))\n",
      "    end if\n",
      "    tempstr =  ' Estimate time :' // trim(tempstr) // '(sec)'\n",
      "    write(*, '(1A$)') trim(tempstr)\n",
      "    \n",
      "    if((n == max) .and. (n_sub == max_sub)) then\n",
      "       write(*,*) ''\n",
      "    end if\n",
      "\n",
      "    call flush(6)\n",
      "  end subroutine progress_bar\n",
      "end module output\n",
      "program main\n",
      "  use setup\n",
      "  use fdtd\n",
      "  use output\n",
      "  implicit none\n",
      "  \n",
      "  integer :: z,i\n",
      "  \n",
      "  call beforeInit\n",
      "  call initialize\n",
      "  call setmodel\n",
      "  call SetMaterialAtCPcell\n",
      "  call SetMaterialAtFeedPoint\n",
      "  \n",
      "  if(id == 0) then\n",
      "     call progress_bar('E-H calculation', 0, nt, 0, 0, 20)\n",
      "  end if\n",
      "  do t=0, nt-1\n",
      "     ! $(B5kEE(B\n",
      "     call calc_feed\n",
      "     ! $(BAw?.LLEE3&7W;;(B\n",
      "     if(PLRCFlag /= 0) then\n",
      "        call calc_PHI(nzS(id))\n",
      "     end if\n",
      "     call calc_E(nzS(id))\n",
      "     if(PLRCFlag /= 0) then\n",
      "        call E_PHI_update(nzS(id))\n",
      "     end if\n",
      "     ! $(BHsF14|Aw<u?.(B\n",
      "     call MPI_Isend(Ex(1,1,nzS(id)), 1, MatrixXY, &\n",
      "          & zm, 0, MPI_COMM_WORLD, request(1), error_code)\n",
      "     call MPI_Isend(Ey(1,1,nzS(id)), 1, MatrixXY, &\n",
      "          & zm, 1, MPI_COMM_WORLD, request(2), error_code)\n",
      "     call MPI_Irecv(Ex(1,1,nzE(id)+1), 1, MatrixXY, &\n",
      "          & zp, 0, MPI_COMM_WORLD, request(3), error_code)\n",
      "     call MPI_Irecv(Ey(1,1,nzE(id)+1), 1, MatrixXY, &\n",
      "          & zp, 1, MPI_COMM_WORLD, request(4), error_code)\n",
      "     ! $(BEE3&7W;;(B\n",
      "     do z=nzS(id)+1, nzE(id)\n",
      "        if(PLRCFlag /= 0) then\n",
      "           call calc_PHI(z)\n",
      "        end if\n",
      "        call calc_E(z)\n",
      "        if(PLRCFlag /= 0) then\n",
      "           call E_PHI_update(z)\n",
      "        end if\n",
      "     enddo\n",
      "     call MPI_Waitall(2, request(3:4), status(:,3:4), error_code)\n",
      "     if((patternFlag /= 0) .or. (efficiencyFlag /= 0)) then\n",
      "     call calc_surface_Jm\n",
      "     endif\n",
      "     if(EDFlag /= 0) then\n",
      "        call calc_Electric_Field_Distribution\n",
      "     end if\n",
      "     call MPI_Waitall(2, request(1:2), status(:,1:2), error_code)\n",
      "     call calc_H(nzE(id))\n",
      "     if((CPFlag == 1) .and. (cpPoint > 0) .and. (cpS(nzE(id)) /= -1)) then\n",
      "        call calc_H_CP(nzE(id))\n",
      "     end if\n",
      "     call MPI_Isend(Hx(1,1,nzE(id)), 1, MatrixXY, &\n",
      "          & zp, 0, MPI_COMM_WORLD, request(1), error_code)\n",
      "     call MPI_Isend(Hy(1,1,nzE(id)), 1, MatrixXY, &\n",
      "          & zp, 1, MPI_COMM_WORLD, request(2), error_code)\n",
      "     call MPI_Irecv(Hx(1,1,nzS(id)-1), 1, MatrixXY, &\n",
      "          & zm, 0, MPI_COMM_WORLD, request(3), error_code)\n",
      "     call MPI_Irecv(Hy(1,1,nzS(id)-1), 1, MatrixXY, &\n",
      "          & zm, 1, MPI_COMM_WORLD, request(4), error_code) \n",
      "     do z=nzE(id)-1, nzS(id), -1\n",
      "        call calc_H(z)\n",
      "        if(CPFlag == 1 .and. cpPoint > 0 .and. cpS(z) /= -1) then\n",
      "           call calc_H_CP(z)\n",
      "        end if\n",
      "     end do\n",
      "     call MPI_Waitall(2, request(3:4), status(:,3:4), error_code)\n",
      "     call calc_I\n",
      "     if((patternFlag /= 0) .or. (efficiencyFlag /= 0)) then\n",
      "     call calc_surface_J\n",
      "     end if\n",
      "     if(CDFlag /= 0) then\n",
      "        call calc_Current_Distribution\n",
      "     end if\n",
      "     call MPI_Waitall(2, request(1:2), status(:,1:2), error_code)\n",
      "     do i=1, nfeed\n",
      "        if((feedAxis(i) == 'z') .and. (feedLength(i) /= 1)) then\n",
      "           call MPI_Bcast(It(i), 1, MPI_DOUBLE_PRECISION, &\n",
      "                & feedNode(i), MPI_COMM_WORLD, error_code)\n",
      "        end if\n",
      "     end do\n",
      "     if(id == 0) then\n",
      "        call progress_bar('E-H calculation', t+1, nt, 0, 0, 20)\n",
      "     end if\n",
      "  end do\n",
      "\n",
      "  ! $(B3F<o=PNO(B\n",
      "  if(impedanceFlag /= 0) then\n",
      "     call out_impedance\n",
      "     call out_VI\n",
      "  end if\n",
      "  if((patternFlag /= 0) .or. (efficiencyFlag /= 0)) then\n",
      "     call calc_Pin\n",
      "  end if\n",
      "  if(patternFlag /= 0) then\n",
      "     call out_pattern\n",
      "  end if\n",
      "  if(efficiencyFlag /= 0) then\n",
      "     call calc_Prad\n",
      "     call out_efficiency\n",
      "  end if\n",
      "  if(CDFlag /= 0) then\n",
      "     call out_Current_Distribution\n",
      "  end if\n",
      "  if(EDFlag /= 0) then\n",
      "     call out_Electric_Field_Distribution\n",
      "  end if\n",
      "\n",
      "  ! $(B=*N;=hM}(B\n",
      "  call MPI_Finalize(error_code)\n",
      "end program main\n",
      "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",
      "!!         !!!!!!              !!!!!!!!!       !!!!!!\n",
      "!!  !!!!!!  !!!!!!!!  !!!!  !!!!!!!!!   !!!!!!!  !!!!\n",
      "!!  !!!!!!  !!!!!!!!  !!!!  !!!!!!!!  !!!!!!!!!!  !!!\n",
      "!!  !!!!!  !!!!!!!!!  !!!!  !!!!!!!  !!!!!!!!!!!!  !!\n",
      "!!  !!   !!!!!!!!!!!  !!!!  !!!!!!!  !!!!!!!!!!!!  !!\n",
      "!!      !!!!!!!!!!!!  !!!!  !!!!!!!  !!!!!!!!!!!!  !!\n",
      "!!  !!!!  !!!!!!!!!!  !!!!  !!!!!!!  !!!!!!!!!!!!  !!\n",
      "!!  !!!!!  !!!!!!!!!  !!!!  !!!!!!!!  !!!!!!!!!!  !!!\n",
      "!!  !!!!!!   !!!!!!!  !!!!  !!!!!!!!!   !!!!!!!  !!!!\n",
      "!!  !!!!!!!   !!!              !!!!!!!!!       !!!!!!\n",
      "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",
      "!!!!!!!!! 2008.Oct. Maeda Tdahiko Laboratory !!!!!!!!\n",
      "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n"
    )
  file.close
end

def outSetFeed(feedNum, startX, startY, startZ, endX, endY, endZ, amp)
  file = File.open($outFileName+".f90","a")
    file.print("    call setfeed(" + feedNum.to_s + ", " + startX.to_s + ", " + startY.to_s + ", " + startZ.to_s +
                            ",   " + endX.to_s + ", " + endY.to_s + ", " + endZ.to_s +
                            ", "   + $innerR + ", " + $type + ", " + $tau + ", " + amp.to_s + "d0)\n")
  file.close

  file = File.open($outFileName+"_feed.txt", "a")
    file.print(startX, " ", startY, " ", startZ, "\n")
    file.print(startX, " ", startY, " ", startZ, "\n")
    file.print(endX,   " ", endY,   " ", endZ,   "\n")
    file.print(endX,   " ", endY,   " ", endZ,   "\n\n\n")
  file.close
end

def outSetPlane(materialNum, startX, startY, startZ, endX, endY, endZ)
  file = File.open($outFileName+".f90","a")
    file.print("    call setplane(", materialNum, ", ", startX, ", ", startY, ", ", startZ, ",   ", endX, ", ", endY, ", ", endZ, ")\n")
  file.close

  file = File.open($outFileName+"_check.txt", "a")
    case
    when startX == endX && startY < endY && startZ < endZ # yz
      file.print(startX, " ", startY, " ", startZ, "\n")
      file.print(startX, " ", endY,   " ", startZ, "\n")
      file.print(startX, " ", endY,   " ", endZ,   "\n")
      file.print(startX, " ", startY,   " ", endZ,   "\n")
      file.print(startX, " ", startY, " ", startZ, "\n\n")

    when startX < endX && startY == endY && startZ < endZ # xz
      file.print(startX, " ", startY, " ", startZ, "\n")
      file.print(startX, " ", startY, " ", endZ,   "\n")
      file.print(endX,   " ", startY, " ", endZ,   "\n")
      file.print(endX,   " ", startY, " ", startZ, "\n")
      file.print(startX, " ", startY, " ", startZ, "\n\n")

    when startX < endX && startY < endY && startZ == endZ # xy
      file.print(startX, " ", startY, " ", startZ, "\n")
      file.print(startX, " ", endY,   " ", startZ, "\n")
      file.print(endX,   " ", endY,   " ", startZ, "\n")
      file.print(endX,   " ", startY, " ", startZ, "\n")
      file.print(startX, " ", startY, " ", startZ, "\n\n")
    else
    end
  file.close
end

def outSetBox(materialNum, startX, startY, startZ, endX, endY, endZ)
  file = File.open($outFileName+".f90","a")
    file.print("    call setbox(", materialNum, ", ", startX, ", ", startY, ", ", startZ, ", ", endX, ", ", endY, ", ", endZ, ")\n")
  file.close

  file = File.open($outFileName+"_check.txt", "a")
    file.print(startX, " ", startY, " ", startZ, "\n")
    file.print(endX,   " ", startY, " ", startZ, "\n")
    file.print(endX,   " ", endY,   " ", startZ, "\n")
    file.print(startX, " ", endY,   " ", startZ, "\n")
    file.print(startX, " ", startY, " ", startZ, "\n\n")

    file.print(startX, " ", startY, " ", endZ,   "\n")
    file.print(startX, " ", endY,   " ", endZ,   "\n")
    file.print(endX,   " ", endY,   " ", endZ,   "\n")
    file.print(endX,   " ", startY, " ", endZ,   "\n")
    file.print(startX, " ", startY, " ", endZ,   "\n")
    file.print(startX, " ", startY, " ", startZ, "\n")
    file.print(startX, " ", startY, " ", endZ,   "\n\n")

    file.print(endX,   " ", startY, " ", startZ, "\n")
    file.print(endX,   " ", startY, " ", endZ,   "\n\n")

    file.print(endX,   " ", endY,   " ", startZ, "\n")
    file.print(endX,   " ", endY,   " ", endZ,   "\n\n")

    file.print(startX, " ", endY,   " ", startZ, "\n")
    file.print(startX, " ", endY,   " ", endZ,   "\n\n")
  file.close
end

def image2model(modelImage)
  # 多次元配列確保
  imageData = Array.new(modelImage.width, nil) # 各要素は、とりあえずnilで初期化.
  imageData.length.times{ |x| # 要素の数だけ..
    imageData[x] = Array.new(modelImage.height, 0 ) # 各要素について、new.
  }

  # ColourDataを抽出
  imageData.length.times{ |x|
    imageData[x].length.times{ |y|
      tempColor = modelImage.pget(x, y)
      case
      when tempColor[R] == 255 && tempColor[G] == 0   && tempColor[B] == 0
        imageData[x][y] = RED

      when tempColor[R] == 255 && tempColor[G] == 255 && tempColor[B] == 0
        imageData[x][y] = YELLOW

      when tempColor[R] == 0   && tempColor[G] == 0   && tempColor[B] == 255
        imageData[x][y] = BLUE

      when tempColor[R] == 0   && tempColor[G] == 255 && tempColor[B] == 255
        imageData[x][y] = SKYBLUE

      when tempColor[R] == 0   && tempColor[G] == 0   && tempColor[B] == 255
        imageData[x][y] = GREEN

      when tempColor[R] == 255 && tempColor[G] == 0   && tempColor[B] == 255
        imageData[x][y] = PURPLE

      when tempColor[R] == 255 && tempColor[G] == 128 && tempColor[B] == 0
        imageData[x][y] = ORANGE

      when tempColor[R] == 0   && tempColor[G] == 128 && tempColor[B] == 255
        imageData[x][y] = LIGHTBLUE

      when tempColor[R] == 255 && tempColor[G] == 255 && tempColor[B] == 255
        imageData[x][y] = WHITE

      else
        imageData[x][y] = BLACK

      end
    }
  }
  return imageData
end

def drawPattern(imageData, baseX, baseY, drawPosition)
  # Start modeling
  imageData[0].length.times{ |y|
    tempImageData = imageData[0][y]
    tempX = 0
    imageData.length.times{ |x|
      if(tempImageData != imageData[x][y])
        if(tempImageData == BLACK || tempImageData == ORANGE)
          outSetPlane(2, baseX+tempX, baseY+y, drawPosition, baseX+x, baseY+y+1, drawPosition)
        end
        tempX = x
        tempImageData = imageData[x][y]
      end
    }
    if(tempImageData == BLACK)
      outSetPlane(2, baseX+tempX, baseY+y, drawPosition, baseX+imageData.length, baseY+y+1, drawPosition)
    end
  }
end

def drawThroghHole(imageData, baseX, baseY, drawPosition)
  imageData[0].length.times{ |y|
    tempImageData = imageData[0][y]
    tempX = 0
    imageData.length.times{ |x|
      if(tempImageData != imageData[x][y])
        if(tempImageData == PURPLE)
          outSetBox(2, baseX+tempX, baseY+y, $baseZ, baseX+x, baseY+y+1, drawPosition)
        end
        tempX = x
        tempImageData = imageData[x][y]
      end
    }
    if(tempImageData == PURPLE)
      outSetBox(2, baseX+tempX, baseY+y, $baseZ, baseX+x, baseY+y+1, drawPosition)
    end
  }
end

def drawFeedPoint(imageData, baseX, baseY, drawPosition)
  feedNum = 1
  imageData.length.times{ |x|
    tempImageData = imageData[x][0]
    tempY = 0
    imageData[x].length.times{ |y|
      if(tempImageData != imageData[x][y])
        case tempImageData
        when RED
          outSetFeed(feedNum, baseX+x, baseY+tempY, drawPosition, baseX+x, baseY+y, drawPosition, 1.0e0)
          feedNum+=1

        when YELLOW
          outSetFeed(feedNum, baseX+x, baseY+y, drawPosition, baseX+x, baseY+tempY, drawPosition, 1.0e0)
          feedNum+=1

        when BLUE
          outSetFeed(feedNum, baseX+x+1, baseY+tempY, drawPosition, baseX+x+1, baseY+y, drawPosition, 0.0e0)
          feedNum+=1

        when SKYBLUE
          outSetFeed(feedNum, baseX+x+1, baseY+y, drawPosition, baseX+x+1, baseY+tempY, drawPosition, 0.0e0)
          feedNum+=1

        when ORANGE
          drawMslFeedPoint(feedNum, baseX+x, baseY+tempY, drawPosition, baseX+x, baseY+y, $baseZ, 1.0e0)
          feedNum+=1

        when LIGHTBLUE
          drawMslFeedPoint(feedNum, baseX+x+1, baseY+tempY, drawPosition, baseX+x+1, baseY+y, $baseZ, 0.0e0)
          feedNum+=1

        end

        tempY = y
        tempImageData = imageData[x][y]
      end
    }
  }
end

def drawMslFeedPoint(feedNum, x, y, z, toX, toY, toZ, amp)
  length = toY - y
  cY = y + length/2
  depth = z - toZ
  step = (length - 1).to_f / (depth - 1).to_f

  if(length.odd?) # 奇数の時
    print("Warnign : This program happend Erorr!!")
  end

  # 階段づくり
  (0..depth-2).each{ |i|
    if(1 > i*step)
      outSetPlane(2, x, cY-(length/2 - i*step).ceil, z-i-1, x, cY+(length/2-i*step).ceil, z-i)
    else # 小さすぎるとき
      outSetPlane(2, x, cY-1, z-i-1, x, cY+1, z-i)
    end
  }

  outSetFeed(feedNum, x, y+length/2, toZ, x, y+length/2, toZ+1, amp)
end

# start main -------------------------------------------------------------
# load image
topImage = BitMap.read(topFileName)
topData = image2model(topImage)
if(bottomFileName)
  bottomImage = BitMap.read(bottomFileName)
  bottomData = image2model(bottomImage)
  if(topImage.width != bottomImage.width && topImage.height != bottomImage.height)
    print(topImage.width, ", ", bottomImage.width, "\n")
    print(topImage.height, ", ", bottomImage.height, "\n")
    raise("Error : Invalid Bitmap's width or height")
  end
end

# init position
baseX = $nx / 2 - topImage.width / 2
baseY = $ny / 2 - topImage.height / 2
$baseZ = $nz / 2 - substrateDepthCells / 2

# file init
file = File.open($outFileName+".f90",'w')
  file.print("! Used Bitmap: '#{topFileName}' & '#{bottomFileName}'\n")
  file.print("! epsR: #{epsR}, freq: #{freq}, tanD: #{tanD}, substrateDepth: #{substrateDepth}\n")
  file.print("! Made at #{Time.now}\n")
file.close
file = File.open($outFileName+"_check.txt",'w'); file.close
file = File.open($outFileName+"_feed.txt",'w');  file.close
file = File.open($outFileName+".gp",'w')
  file.print("spl '#{$outFileName}_check.txt' w l, '#{$outFileName}_feed.txt' w l")
file.close

outSetHeader()

# 媒質定義
file = File.open($outFileName+".f90",'a')
  file.print("    call medium(2, 5.760d7, 1.0d0)  !Cupper\n")
  file.print("    call medium(3, #{substrateSigma}0d0, #{epsR}0d0)  !Substrate\n")
  file.print("    call medium(4, #{substrateSigma/2}0d0, #{(epsR+1)/2}0d0)  !surface\n\n")
file.close

# out substrate
outSetBox(3, baseX, baseY, $baseZ, baseX+topImage.width, baseY+topImage.height, $baseZ+substrateDepthCells)
outSetPlane(4, baseX, baseY, $baseZ, baseX+topImage.width, baseY+topImage.height, $baseZ)
outSetPlane(4, baseX, baseY, $baseZ+substrateDepthCells, baseX+topImage.width, baseY+topImage.height, $baseZ+substrateDepthCells)

# Draw top model
file = File.open($outFileName+".f90",'a')
  file.print("\n\n! Top pattern ----\n")
file.close
drawPattern(topData, baseX, baseY, $baseZ+substrateDepthCells)

# Draw bottom model
file = File.open($outFileName+".f90",'a')
  file.print("\n\n! Bottom pattern ----\n")
file.close
if(bottomFileName)
  drawPattern(bottomData, baseX, baseY, $baseZ)
end

# Draw throgh hole
file = File.open($outFileName+".f90",'a')
  file.print("\n\n! Throgh hole ----\n")
file.close
drawThroghHole(topData, baseX, baseY, $baseZ+substrateDepthCells)

# Draw feed point
file = File.open($outFileName+".f90",'a')
  file.print("\n\n! Feed point ----\n")
file.close
drawFeedPoint(topData, baseX, baseY, $baseZ+substrateDepthCells)

outSetFooter()
